--loadstring(game:HttpGet('SCRIPTLINK', true))()

if game.PlaceId == 2317712696 then -- The wild west
loadstring(game:HttpGet('https://raw.githubusercontent.com/lolocahhh45/s2S2SMlamW/main/Venushack%201.5.0.txt', true))()
_G.Supported = true
elseif game.PlaceId == 6924952561 then -- Clover city
loadstring(game:HttpGet('https://raw.githubusercontent.com/lolocahhh45/s2S2SMlamW/main/3', true))()
_G.Supported = true
end

if _G.Supported == nil then game.StarterGui:SetCore("SendNotification", {Title = "GAME NO SUPPORTED", Text = "This game is not supported, A good GUI with much things has been load!, Made by lolocahhh#7354", Duration = 5,})

game.StarterGui:SetCore("ChatMakeSystemMessage", {
Text = "Script Executed!"; --chat notification
Font = Enum.Font.GothamBlack; --font changeable
FontSize = Enum.FontSize.Size24; --font size changeable
})
wait()
game.StarterGui:SetCore("ChatMakeSystemMessage", {
Text = "SC hub 1.0"; --chat notification
Font = Enum.Font.GothamBlack; --font changeable
FontSize = Enum.FontSize.Size24; --font size changeable
})
wait(2)
game.StarterGui:SetCore("ChatMakeSystemMessage", {
Text = "SC hub 1.0"; --chat notification
Font = Enum.Font.GothamBlack; --font changeable
FontSize = Enum.FontSize.Size24; --font size changeable
})
wait(2)
game.StarterGui:SetCore("ChatMakeSystemMessage", {
Text = "SC hub loaded"; --chat notification
Font = Enum.Font.GothamBlack; --font changeable
FontSize = Enum.FontSize.Size24; --font size changeable
})
wait()
--Setup 2

_G.lol = 16 --Walkspeed


--Setup 2 ended
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()
local Window = Library.CreateLib("SC hub 1.0 | By lolocahhh45#7354 | Game = ???", "BloodTheme")

local Tab = Window:NewTab("Main")
local Section = Tab:NewSection("Solo script")
Section:NewButton("Free cam", "Press SHITF+P For turn on", function()
    loadstring(game:HttpGet("https://pastebin.com/raw/ct8Kq5F0", true))()
end)
Section:NewToggle("Auto WalkSpeed", "Turns on walkspeed every 0.2s", function(state2)
        if state2 then
            _G.DO44 = true
                    while wait(0.2) and _G.DO44 == true do
    
                        getgenv().WalkSpeedValue = _G.lol;
                        local Player = game:service'Players'.LocalPlayer;
                        Player.Character.Humanoid:GetPropertyChangedSignal'WalkSpeed':Connect(function()
                        Player.Character.Humanoid.WalkSpeed = getgenv().WalkSpeedValue;
                        end)
                        Player.Character.Humanoid.WalkSpeed = getgenv().WalkSpeedValue;
    end
        else
             _G.DO44 = false
        end
    end)
    
    Section:NewSlider("WalkSpeed", "Just walkspeed changuer", 90, 1, function(sk)
        _G.lol = sk
        getgenv().WalkSpeedValue = sk;
    local Player = game:service'Players'.LocalPlayer;
    Player.Character.Humanoid:GetPropertyChangedSignal'WalkSpeed':Connect(function()
    Player.Character.Humanoid.WalkSpeed = getgenv().WalkSpeedValue;
    end)
    Player.Character.Humanoid.WalkSpeed = getgenv().WalkSpeedValue;
    end)
Section:NewButton("Light", "Just light | Click again = more light | !LOCAL!", function()
    character = game:GetService("Players").LocalPlayer.Character
pointLight = Instance.new("PointLight")
pointLight.Parent = character.HumanoidRootPart
end)
Section:NewButton("Noclip", "That is great no?", function()
    if _G.Noclip == nil or not _G.Noclip.Connected then
lp = game:service'Players'.LocalPlayer
_G.Noclip = game:service'RunService'.Stepped:Connect(function()
lp.Character.Head.CanCollide = false
lp.Character.LowerTorso.CanCollide = false
lp.Character.UpperTorso.CanCollide = false
lp.Character.HumanoidRootPart.CanCollide = false
if lp.Character:FindFirstChild'Badge' then
lp.Character.Badge.CanCollide = false
end
end)
end
end)
Section:NewSlider("Cframe walk speed", "OP", 5, 0, function(x) -- 5 (MaxValue) | 1 (MinValue)
        _G.CframeWalk = x
    end)
    Section:NewButton("Cframe walk", "CFrame walk (Press LeftShift)", function()
        local Player = game:GetService'Players'.LocalPlayer;
    local UIS = game:GetService'UserInputService';
    UIS.InputBegan:connect(function(UserInput)
            if UserInput.UserInputType == Enum.UserInputType.Keyboard and UserInput.KeyCode == Enum.KeyCode.LeftShift then
                _G.Running = true
                    while wait(0.001) and _G.Running == true do
    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame + game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame.lookVector * _G.CframeWalk
    end
            end
    end)
    UIS.InputEnded:connect(function(UserInput)
            if UserInput.UserInputType == Enum.UserInputType.Keyboard and UserInput.KeyCode == Enum.KeyCode.LeftShift then
                    _G.Running = false
            end
    end)
    end)
Section:NewToggle("No gravity", "Gravity toggle", function(state)
    if state then

        loadstring(game:HttpGet("\104\116\116\112\115\58\47\47\114\97\119\46\103\105\116\104\117\98\117\115\101\114\99\111\110\116\101\110\116\46\99\111\109\47\75\101\111\110\101\71\105\116\104\117\98\83\112\97\109\47\75\101\111\110\101\71\105\116\104\117\98\83\112\97\109\47\109\97\105\110\47\71\114\97\118\105\116\121\115\47\103\114\97\118\105\116\121\79\110"))()
    else
    
        loadstring(game:HttpGet("\104\116\116\112\115\58\47\47\114\97\119\46\103\105\116\104\117\98\117\115\101\114\99\111\110\116\101\110\116\46\99\111\109\47\75\101\111\110\101\71\105\116\104\117\98\83\112\97\109\47\75\101\111\110\101\71\105\116\104\117\98\83\112\97\109\47\109\97\105\110\47\71\114\97\118\105\116\121\115\47\71\114\97\118\105\116\121\79\102\102"))()
    end
end)
Section:NewToggle("Hight HipHeight", "idk", function(state)
        if state then
            loadstring(game:HttpGet("\104\116\116\112\115\58\47\47\114\97\119\46\103\105\116\104\117\98\117\115\101\114\99\111\110\116\101\110\116\46\99\111\109\47\75\101\111\110\101\71\105\116\104\117\98\83\112\97\109\47\75\101\111\110\101\71\105\116\104\117\98\83\112\97\109\47\109\97\105\110\47\72\105\112\72\101\105\103\104\116\115\47\72\105\112\104\101\105\103\104\116\65\98\105\116"))()
        else
            loadstring(game:HttpGet('https://raw.githubusercontent.com/KeoneGithubSpam/KeoneGithubSpam/main/HipHeights/HipheightNormal'))()
        end
    end)
    Section:NewToggle("Low HipHeight", "idk", function(state)
        if state then
            loadstring(game:HttpGet("\104\116\116\112\115\58\47\47\114\97\119\46\103\105\116\104\117\98\117\115\101\114\99\111\110\116\101\110\116\46\99\111\109\47\75\101\111\110\101\71\105\116\104\117\98\83\112\97\109\47\75\101\111\110\101\71\105\116\104\117\98\83\112\97\109\47\109\97\105\110\47\72\105\112\72\101\105\103\104\116\115\47\77\111\100\101\114\97\116\111\114\72\101\105\103\104\116"))()
        else
            loadstring(game:HttpGet('https://raw.githubusercontent.com/KeoneGithubSpam/KeoneGithubSpam/main/HipHeights/HipheightNormal'))()
        end
    end)
    _G.delai = 1
    Section:NewTextBox("Auto message delai", "type in the box the delai", function(msgxd1)
        _G.delai = msgxd1
    end)
    Section:NewTextBox("message", "Type in the box the message", function(msgxd)
        _G.message = msgxd
    end)
    Section:NewToggle("Auto msg", "UH", function(state2)
        if state2 then
            _G.DO414 = true
                    while wait(_G.delai) and _G.DO414 == true do
    
                        game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(_G.message, "All")
    end
        else
             _G.DO414 = false
        end
    end)
    Section:NewButton("AntiAFK", "idk how this works", function()
        loadstring(game:HttpGet('https://cdn.y2k06.xyz/lua/UniversalAntiAfk.lua', true))()
    end)
    


Section:NewToggle("Inf Jump", "Jump in air ðŸ¤‘", function(state)
    if state then
        loadstring(game:HttpGet("https://pastebin.com/raw/HQsQysa8", true))()
    else
        _G.infinjump = false
 
local Player = game:GetService("Players").LocalPlayer
local Mouse = Player:GetMouse()
Mouse.KeyDown:connect(function(k)
if _G.infinjump then
if k:byte() == 32 then
Humanoid = game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
Humanoid:ChangeState("Jumping")
wait(0.1)
Humanoid:ChangeState("Seated")
end
end
end)
    end
end)
Section:NewButton("Click tp", "CTRL + CLICK", function()
    noclip = false
local UIS = game:GetService("UserInputService")
local Player = game.Players.LocalPlayer
local Mouse = Player:GetMouse()


function GetCharacter()
   return game.Players.LocalPlayer.Character
end

function Teleport(pos)
   local Char = GetCharacter()
   if Char then
       Char:MoveTo(pos)
   end
end


UIS.InputBegan:Connect(function(input)
   if input.UserInputType == Enum.UserInputType.MouseButton1 and UIS:IsKeyDown(Enum.KeyCode.LeftControl) then
       Teleport(Mouse.Hit.p)
   end
end)
end)
    local Tab = Window:NewTab("Combat W")
    local Section = Tab:NewSection("ALERT! Gun mods can be detect by players!!!")
    Section:NewLabel("Hitbox")

    Section:NewSlider("Hitbox", "Solo Script on top", 40, 1, function(p) -- 40 (MaxValue) | 1 (MinValue)
        _G.Hitbox = p
    end)
    Section:NewButton("Hitbox", "N = ON | B = OFF | Giant hitbox OP for pvp", function()
        game:GetService("StarterGui"):SetCore("SendNotification", {Title = "Loaded", Text = "n = Enabled | b = disabled,By ðŸ’ŽSolo ScriptðŸ’Ž"})
    local player = game.Players.LocalPlayer
    local mouse = player:GetMouse()
    
    -- Settings
    
    bind = ""
    bind2 = _G.KeyDamsh1
    bind3 = _G.KeyDamsh2

    if _G.KeyDamsh1 == nil then
     _G.KeyDamsh1 = "n"
     print("Turn off hitbox key changed to N")
     else
     print("Key1 ins't nil")
      end

    if _G.KeyDamsh2 == nil then
     _G.KeyDamsh2 = "k"
     print("Turn off hitbox key changed to B")
     else
     print("Key2 ins't nil")
      end
    
    -- Script
    
    mouse.KeyDown:connect(function(key)
    if key == bind then
    player.Character.HumanoidRootPart.CFrame = CFrame.new(1254.09656, 137.906067, -172.128204)
    end
    end)
    
    mouse.KeyDown:connect(function(key2)
    if key2 == bind2 then
    _G.HeadSize = _G.Hitbox
    _G.Disabled = true
    
    
    if _G.Disabled then
    for i,v in next, game:GetService('Players'):GetPlayers() do
    if v.Name ~= game:GetService('Players').LocalPlayer.Name then
    pcall(function()
    v.Character.HumanoidRootPart.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize)
    v.Character.HumanoidRootPart.Transparency = 0.7
    v.Character.HumanoidRootPart.BrickColor = BrickColor.new("Bright red")
    v.Character.HumanoidRootPart.Material = "Neon"
    v.Character.HumanoidRootPart.CanCollide = false
    end)
    end
    end
    end
    end
    end)
    
    mouse.KeyDown:connect(function(key3)
    if key3 == bind3 then
    _G.HeadSize = 2
    _G.Disabled = true
    
    
    for i,v in next, game:GetService('Players'):GetPlayers() do
    if v.Name ~= game:GetService('Players').LocalPlayer.Name then
    pcall(function()
    v.Character.HumanoidRootPart.Size = Vector3.new(2, 2, 1)
    v.Character.HumanoidRootPart.Transparency = 1
    v.Character.HumanoidRootPart.BrickColor = BrickColor.new("Medium stone grey")
    v.Character.HumanoidRootPart.Material = "Plastic"
    v.Character.HumanoidRootPart.CanCollide = false
    end)
    end
    end
    end
    end)
    
    end)

Section:NewTextBox("TURN ON HITBOX", "Type here your key", function(txl2)
	_G.KeyDamsh1 = txl2
end)
Section:NewTextBox("TURN OFF HITBOX", "Type here your key", function(txl2)
	_G.KeyDamsh2 = txl2
end)
Section:NewLabel("only lower case! (Keybinds)")
Section:NewLabel("Click hitbox button again to aply")

    Section:NewLabel("AIM SCRIPTS")
    Section:NewLabel("Aimbot")
    Section:NewSlider("Fov Radius", "Default = 120", 420, 20, function(s1)
        _G.CircleRadius = s1
    end)
    Section:NewToggle("Fov Visible", "Defaults to true", function(state)
        if state then
            _G.CircleVisible = true
        else
            _G.CircleVisible = false
        end
    end)
    Section:NewToggle("Toggle aimbot", "Defaults to true", function(state)
        if state then
            _G.AimbotEnabled = true
        else
            _G.AimbotEnabled = false
        end
    end)
    Section:NewToggle("TeamCheck", "Defaults to false", function(state)
        if state then
            _G.TeamCheck = true
        else
            _G.TeamCheck = false
        end
    end)
    Section:NewButton("Aimbot (Worst)", "Key = MouseButton2", function()
            --Aimbot by lolocahhh45
        
            local Players = game:GetService("Players")
            local LocalPlayer = Players.LocalPlayer
            local Camera = workspace.CurrentCamera
            local RunService = game:GetService("RunService")
            local UserInputService = game:GetService("UserInputService")
            local TweenService = game:GetService("TweenService")
            local Holding = false
        
            --Aimbot settings
        
            _G.AimbotEnabled = true
            _G.TeamCheck = false
            _G.AimPart = "Head"
            _G.Sensitivity = 0.000000000001
        
            -- Fov Circle Settings
        
            _G.CircleSides = 64
            _G.CircleColor = Color3.fromRGB(255, 255, 255)
            _G.CircleTransparency = 1
            _G.CircleRadius = 120
            _G.CircleFilled = false
            _G.CircleVisible = true
            _G.CircleThickness = false
        
            local FOVCircle = Drawing.new("Circle")
        
            FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
            FOVCircle.Radius = _G.CircleRadius
            FOVCircle.Filled = _G.CircleFilled
            FOVCircle.Color = _G.CircleColor
            FOVCircle.Visible = _G.CircleVisible
            FOVCircle.Transparency = _G.CircleTransparency
            FOVCircle.Sides = _G.CircleSides
            FOVCircle.Thickness = _G.CircleThickness
        
            --Gets players for fov
        
            local function getClosestPlayer()
                local MaximumDistance = _G.CircleRadius
                local Target = nil
        
                for _, v in next, Players:GetPlayers() do
                    if v.Name ~= LocalPlayer.Name then 
                        if _G.TeamCheck == true then
                            if  v.Team ~= LocalPlayer.Team then
                                if v.Character ~= nil then
                                    if v.Character:FindFirstChild("HumanoidRootPart") ~= nil then
                                        if v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("Humanoid").Health ~= 0 then
                                            local ScreenPoint = Camera:WorldToScreenPoint(v.Character:WaitForChild("HumanoidRootPart", math.huge).Position)
                                            local VectorDistance = (Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
        
                                            if VectorDistance < MaximumDistance then
                                                Target = v
                                            end
                                        end
                                    end
                                end
                            end
                        else
                            if v.Character ~= nil then
                                if v.Character:FindFirstChild("HumanoidRootPart") ~= nil then
                                    if v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("Humanoid").Health ~= 0 then
                                        local ScreenPoint = Camera:WorldToScreenPoint(v.Character:WaitForChild("HumanoidRootPart", math.huge).Position)
                                        local VectorDistance = (Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
        
                                        if VectorDistance < MaximumDistance then
                                            Target = v
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                
                return Target
            end    
        
        --Detect when you press Z and make Holding = true / Holding = false
        
        UserInputService.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton2 then
                Holding = true
            end
        end)  
        
        UserInputService.InputEnded:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton2 then
                Holding = false
            end
        end)
        
            RunService.RenderStepped:Connect(function()
                FOVCircle.Position = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                FOVCircle.Radius = _G.CircleRadius
                FOVCircle.Filled = _G.CircleFilled
                FOVCircle.Color = _G.CircleColor
                FOVCircle.Visible = _G.CircleVisible
                FOVCircle.Transparency = _G.CircleTransparency
                FOVCircle.Sides = _G.CircleSides
                FOVCircle.Thickness = _G.CircleThickness
        
                if Holding == true and _G.AimbotEnabled == true then
                    TweenService:Create(Camera, TweenInfo.new(_G.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, getClosestPlayer().Character[_G.AimPart].Position)}):Play()
                end
            end)
    end)
    Section:NewButton("Aimbot Hub (better option)", "Nothing happen? tell in dc", function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Blissful4992/Miscellaneous/main/UNIVERSAL.lua"))()
    end)
    Section:NewLabel("Silent aim")
    Section:NewButton("Silent aim (universal)", "Toggle = Right alt (ADDED IN 1.4.5)", function()
        -- loader
if not game:IsLoaded() then 
    game.Loaded:Wait()
end

if not syn or not protectgui then
    getgenv().protectgui = function() end
end

local SilentAimSettings = {
    Enabled = true,
    
    ClassName = "Universal Silent Aim - Modified by solo script",
    ToggleKey = "RightAlt",
    
    TeamCheck = true,
    VisibleCheck = false, 
    TargetPart = "HumanoidRootPart",
    SilentAimMethod = "Raycast",
    
    FOVRadius = 200,
    FOVVisible = false,
    ShowSilentAimTarget = false, 
    
    MouseHitPrediction = false,
    MouseHitPredictionAmount = 0.165,
    HitChance = 100
}

-- variables
getgenv().SilentAimSettings = Settings
local MainFileName = "UniversalSilentAim"
local SelectedFile, FileToSave = "", ""

local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local GetChildren = game.GetChildren
local GetPlayers = Players.GetPlayers
local WorldToScreen = Camera.WorldToScreenPoint
local WorldToViewportPoint = Camera.WorldToViewportPoint
local GetPartsObscuringTarget = Camera.GetPartsObscuringTarget
local FindFirstChild = game.FindFirstChild
local RenderStepped = RunService.RenderStepped
local GuiInset = GuiService.GetGuiInset
local GetMouseLocation = UserInputService.GetMouseLocation

local resume = coroutine.resume 
local create = coroutine.create

local ValidTargetParts = {"Head", "HumanoidRootPart"}
local PredictionAmount = 0.165

local mouse_box = Drawing.new("Square")
mouse_box.Visible = true 
mouse_box.ZIndex = 999 
mouse_box.Color = Color3.fromRGB(54, 57, 241)
mouse_box.Thickness = 20 
mouse_box.Size = Vector2.new(20, 20)
mouse_box.Filled = true 

local fov_circle = Drawing.new("Circle")
fov_circle.Thickness = 1
fov_circle.NumSides = 100
fov_circle.Radius = 180
fov_circle.Filled = false
fov_circle.Visible = false
fov_circle.ZIndex = 999
fov_circle.Transparency = 1
fov_circle.Color = Color3.fromRGB(54, 57, 241)

local ExpectedArguments = {
    FindPartOnRayWithIgnoreList = {
        ArgCountRequired = 3,
        Args = {
            "Instance", "Ray", "table", "boolean", "boolean"
        }
    },
    FindPartOnRayWithWhitelist = {
        ArgCountRequired = 3,
        Args = {
            "Instance", "Ray", "table", "boolean"
        }
    },
    FindPartOnRay = {
        ArgCountRequired = 2,
        Args = {
            "Instance", "Ray", "Instance", "boolean", "boolean"
        }
    },
    Raycast = {
        ArgCountRequired = 3,
        Args = {
            "Instance", "Vector3", "Vector3", "RaycastParams"
        }
    }
}

function CalculateChance(Percentage)
    -- // Floor the percentage
    Percentage = math.floor(Percentage)

    -- // Get the chance
    local chance = math.floor(Random.new().NextNumber(Random.new(), 0, 1) * 100) / 100

    -- // Return
    return chance <= Percentage / 100
end


--[[file handling]] do 
    if not isfolder(MainFileName) then 
        makefolder(MainFileName);
    end
    
    if not isfolder(string.format("%s/%s", MainFileName, tostring(game.PlaceId))) then 
        makefolder(string.format("%s/%s", MainFileName, tostring(game.PlaceId)))
    end
end

local Files = listfiles(string.format("%s/%s", "UniversalSilentAim", tostring(game.PlaceId)))

-- functions
local function GetFiles() -- credits to the linoria lib for this function, listfiles returns the files full path and its annoying
	local out = {}
	for i = 1, #Files do
		local file = Files[i]
		if file:sub(-4) == '.lua' then
			-- i hate this but it has to be done ...

			local pos = file:find('.lua', 1, true)
			local start = pos

			local char = file:sub(pos, pos)
			while char ~= '/' and char ~= '\\' and char ~= '' do
				pos = pos - 1
				char = file:sub(pos, pos)
			end

			if char == '/' or char == '\\' then
				table.insert(out, file:sub(pos + 1, start - 1))
			end
		end
	end
	
	return out
end

local function UpdateFile(FileName)
    assert(FileName or FileName == "string", "oopsies");
    writefile(string.format("%s/%s/%s.lua", MainFileName, tostring(game.PlaceId), FileName), HttpService:JSONEncode(SilentAimSettings))
end

local function LoadFile(FileName)
    assert(FileName or FileName == "string", "oopsies");
    
    local File = string.format("%s/%s/%s.lua", MainFileName, tostring(game.PlaceId), FileName)
    local ConfigData = HttpService:JSONDecode(readfile(File))
    for Index, Value in next, ConfigData do
        SilentAimSettings[Index] = Value
    end
end

local function getPositionOnScreen(Vector)
    local Vec3, OnScreen = WorldToScreen(Camera, Vector)
    return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end

local function ValidateArguments(Args, RayMethod)
    local Matches = 0
    if #Args < RayMethod.ArgCountRequired then
        return false
    end
    for Pos, Argument in next, Args do
        if typeof(Argument) == RayMethod.Args[Pos] then
            Matches = Matches + 1
        end
    end
    return Matches >= RayMethod.ArgCountRequired
end

local function getDirection(Origin, Position)
    return (Position - Origin).Unit * 1000
end

local function getMousePosition()
    return GetMouseLocation(UserInputService)
end

local function IsPlayerVisible(Player)
    local PlayerCharacter = Player.Character
    local LocalPlayerCharacter = LocalPlayer.Character
    
    if not (PlayerCharacter or LocalPlayerCharacter) then return end 
    
    local PlayerRoot = FindFirstChild(PlayerCharacter, Options.TargetPart.Value) or FindFirstChild(PlayerCharacter, "HumanoidRootPart")
    
    if not PlayerRoot then return end 
    
    local CastPoints, IgnoreList = {PlayerRoot.Position, LocalPlayerCharacter, PlayerCharacter}, {LocalPlayerCharacter, PlayerCharacter}
    local ObscuringObjects = #GetPartsObscuringTarget(Camera, CastPoints, IgnoreList)
    
    return ((ObscuringObjects == 0 and true) or (ObscuringObjects > 0 and false))
end

local function getClosestPlayer()
    if not Options.TargetPart.Value then return end
    local Closest
    local DistanceToMouse
    for _, Player in next, GetPlayers(Players) do
        if Player == LocalPlayer then continue end
        if Toggles.TeamCheck.Value and Player.Team == LocalPlayer.Team then continue end

        local Character = Player.Character
        if not Character then continue end
        
        if Toggles.VisibleCheck.Value and not IsPlayerVisible(Player) then continue end

        local HumanoidRootPart = FindFirstChild(Character, "HumanoidRootPart")
        local Humanoid = FindFirstChild(Character, "Humanoid")
        if not HumanoidRootPart or not Humanoid or Humanoid and Humanoid.Health <= 0 then continue end

        local ScreenPosition, OnScreen = getPositionOnScreen(HumanoidRootPart.Position)
        if not OnScreen then continue end

        local Distance = (getMousePosition() - ScreenPosition).Magnitude
        if Distance <= (DistanceToMouse or Options.Radius.Value or 2000) then
            Closest = ((Options.TargetPart.Value == "Random" and Character[ValidTargetParts[math.random(1, #ValidTargetParts)]]) or Character[Options.TargetPart.Value])
            DistanceToMouse = Distance
        end
    end
    return Closest
end

-- ui creating & handling
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/Library.lua"))()

local Window = Library:CreateWindow("Universal Silent Aim - Modified by solo script")
local GeneralTab = Window:AddTab("General")
local MainBOX = GeneralTab:AddLeftTabbox("Main") do
    local Main = MainBOX:AddTab("Main")
    
    Main:AddToggle("aim_Enabled", {Text = "Enabled"}):AddKeyPicker("aim_Enabled_KeyPicker", {Default = "RightAlt", SyncToggleState = true, Mode = "Toggle", Text = "Enabled", NoUI = false});
    Options.aim_Enabled_KeyPicker:OnClick(function()
        SilentAimSettings.Enabled = not SilentAimSettings.Enabled
        
        Toggles.aim_Enabled.Value = SilentAimSettings.Enabled
        Toggles.aim_Enabled:SetValue(SilentAimSettings.Enabled)
        
        mouse_box.Visible = SilentAimSettings.Enabled
    end)
    
    Main:AddToggle("TeamCheck", {Text = "Team Check", Default = SilentAimSettings.TeamCheck}):OnChanged(function()
        SilentAimSettings.TeamCheck = Toggles.TeamCheck.Value
    end)
    Main:AddToggle("VisibleCheck", {Text = "Visible Check", Default = SilentAimSettings.VisibleCheck}):OnChanged(function()
        SilentAimSettings.VisibleCheck = Toggles.VisibleCheck.Value
    end)
    Main:AddDropdown("TargetPart", {Text = "Target Part", Default = SilentAimSettings.TargetPart, Values = {"Head", "HumanoidRootPart", "Random"}}):OnChanged(function()
        SilentAimSettings.TargetPart = Options.TargetPart.Value
    end)
    Main:AddDropdown("Method", {Text = "Silent Aim Method", Default = SilentAimSettings.SilentAimMethod, Values = {
        "Raycast","FindPartOnRay",
        "FindPartOnRayWithWhitelist",
        "FindPartOnRayWithIgnoreList",
        "Mouse.Hit/Target"
    }}):OnChanged(function() 
        SilentAimSettings.SilentAimMethod = Options.Method.Value 
    end)
    Main:AddSlider('HitChance', {
        Text = 'Hit chance',
        Default = 100,
        Min = 0,
        Max = 100,
        Rounding = 1,
    
        Compact = false,
    })
    Options.HitChance:OnChanged(function()
        SilentAimSettings.HitChance = Options.HitChance.Value
    end)
end

local MiscellaneousBOX = GeneralTab:AddLeftTabbox("Miscellaneous")
local FieldOfViewBOX = GeneralTab:AddLeftTabbox("Field Of View") do
    local Main = FieldOfViewBOX:AddTab("Visuals")
    
    Main:AddToggle("Visible", {Text = "Show FOV Circle"}):AddColorPicker("Color", {Default = Color3.fromRGB(54, 57, 241)}):OnChanged(function()
        fov_circle.Visible = Toggles.Visible.Value
        SilentAimSettings.FOVVisible = Toggles.Visible.Value
    end)
    Main:AddSlider("Radius", {Text = "FOV Circle Radius", Min = 0, Max = 360, Default = 130, Rounding = 0}):OnChanged(function()
        fov_circle.Radius = Options.Radius.Value
        SilentAimSettings.FOVRadius = Options.Radius.Value
    end)
    Main:AddToggle("MousePosition", {Text = "Show Silent Aim Target"}):AddColorPicker("MouseVisualizeColor", {Default = Color3.fromRGB(54, 57, 241)}):OnChanged(function()
        mouse_box.Visible = Toggles.MousePosition.Value 
        SilentAimSettings.ShowSilentAimTarget = Toggles.MousePosition.Value 
    end)
    local PredictionTab = MiscellaneousBOX:AddTab("Prediction")
    PredictionTab:AddToggle("Prediction", {Text = "Mouse.Hit/Target Prediction"}):OnChanged(function()
        SilentAimSettings.MouseHitPrediction = Toggles.Prediction.Value
    end)
    PredictionTab:AddSlider("Amount", {Text = "Prediction Amount", Min = 0.165, Max = 1, Default = 0.165, Rounding = 3}):OnChanged(function()
        PredictionAmount = Options.Amount.Value
        SilentAimSettings.MouseHitPredictionAmount = Options.Amount.Value
    end)
end

local CreateConfigurationBOX = GeneralTab:AddRightTabbox("Create Configuration") do 
    local Main = CreateConfigurationBOX:AddTab("Create Configuration")
    
    Main:AddInput("CreateConfigTextBox", {Default = "", Numeric = false, Finished = false, Text = "Create Configuration to Create", Tooltip = "Creates a configuration file containing settings you can save and load", Placeholder = "File Name here"}):OnChanged(function()
        if Options.CreateConfigTextBox.Value and string.len(Options.CreateConfigTextBox.Value) ~= "" then 
            FileToSave = Options.CreateConfigTextBox.Value
        end
    end)
    
    Main:AddButton("Create Configuration File", function()
        if FileToSave ~= "" or FileToSave ~= nil then 
            UpdateFile(FileToSave)
        end
    end)
end

local SaveConfigurationBOX = GeneralTab:AddRightTabbox("Save Configuration") do 
    local Main = SaveConfigurationBOX:AddTab("Save Configuration")
    Main:AddDropdown("SaveConfigurationDropdown", {Values = GetFiles(), Text = "Choose Configuration to Save"})
    Main:AddButton("Save Configuration", function()
        if Options.SaveConfigurationDropdown.Value then 
            UpdateFile(Options.SaveConfigurationDropdown.Value)
        end
    end)
end

local LoadConfigurationBOX = GeneralTab:AddRightTabbox("Load Configuration") do 
    local Main = LoadConfigurationBOX:AddTab("Load Configuration")
    
    Main:AddDropdown("LoadConfigurationDropdown", {Values = GetFiles(), Text = "Choose Configuration to Load"})
    Main:AddButton("Load Configuration", function()
        if table.find(GetFiles(), Options.LoadConfigurationDropdown.Value) then
            LoadFile(Options.LoadConfigurationDropdown.Value)
            
            Toggles.TeamCheck:SetValue(SilentAimSettings.TeamCheck)
            Toggles.VisibleCheck:SetValue(SilentAimSettings.VisibleCheck)
            Options.TargetPart:SetValue(SilentAimSettings.TargetPart)
            Options.Method:SetValue(SilentAimSettings.SilentAimMethod)
            Toggles.Visible:SetValue(SilentAimSettings.FOVVisible)
            Options.Radius:SetValue(SilentAimSettings.FOVRadius)
            Toggles.MousePosition:SetValue(SilentAimSettings.ShowSilentAimTarget)
            Toggles.Prediction:SetValue(SilentAimSettings.MouseHitPrediction)
            Options.Amount:SetValue(SilentAimSettings.MouseHitPredictionAmount)
            Options.HitChance:SetValue(SilentAimSettings.HitChance)
        end
    end)
end

resume(create(function()
    RenderStepped:Connect(function()
        if Toggles.MousePosition.Value and Toggles.aim_Enabled.Value then
            if getClosestPlayer() then 
                local Root = getClosestPlayer().Parent.PrimaryPart or getClosestPlayer()
                local RootToViewportPoint, IsOnScreen = WorldToViewportPoint(Camera, Root.Position);
                -- using PrimaryPart instead because if your Target Part is "Random" it will flicker the square between the Target's Head and HumanoidRootPart (its annoying)
                
                mouse_box.Visible = IsOnScreen
                mouse_box.Position = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y)
            else 
                mouse_box.Visible = false 
                mouse_box.Position = Vector2.new()
            end
        end
        
        if Toggles.Visible.Value then 
            fov_circle.Visible = Toggles.Visible.Value
            fov_circle.Color = Options.Color.Value
            fov_circle.Position = getMousePosition()
        end
    end)
end))

-- hooks
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
    local Method = getnamecallmethod()
    local Arguments = {...}
    local self = Arguments[1]
    local chance = CalculateChance(SilentAimSettings.HitChance)
    if Toggles.aim_Enabled.Value and self == workspace and not checkcaller() and chance == true then
        if Method == "FindPartOnRayWithIgnoreList" and Options.Method.Value == Method then
            if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRayWithIgnoreList) then
                local A_Ray = Arguments[2]

                local HitPart = getClosestPlayer()
                if HitPart then
                    local Origin = A_Ray.Origin
                    local Direction = getDirection(Origin, HitPart.Position)
                    Arguments[2] = Ray.new(Origin, Direction)

                    return oldNamecall(unpack(Arguments))
                end
            end
        elseif Method == "FindPartOnRayWithWhitelist" and Options.Method.Value == Method then
            if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRayWithWhitelist) then
                local A_Ray = Arguments[2]

                local HitPart = getClosestPlayer()
                if HitPart then
                    local Origin = A_Ray.Origin
                    local Direction = getDirection(Origin, HitPart.Position)
                    Arguments[2] = Ray.new(Origin, Direction)

                    return oldNamecall(unpack(Arguments))
                end
            end
        elseif (Method == "FindPartOnRay" or Method == "findPartOnRay") and Options.Method.Value:lower() == Method:lower() then
            if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRay) then
                local A_Ray = Arguments[2]

                local HitPart = getClosestPlayer()
                if HitPart then
                    local Origin = A_Ray.Origin
                    local Direction = getDirection(Origin, HitPart.Position)
                    Arguments[2] = Ray.new(Origin, Direction)

                    return oldNamecall(unpack(Arguments))
                end
            end
        elseif Method == "Raycast" and Options.Method.Value == Method then
            if ValidateArguments(Arguments, ExpectedArguments.Raycast) then
                local A_Origin = Arguments[2]

                local HitPart = getClosestPlayer()
                if HitPart then
                    Arguments[3] = getDirection(A_Origin, HitPart.Position)

                    return oldNamecall(unpack(Arguments))
                end
            end
        end
    end
    return oldNamecall(...)
end))

local oldIndex = nil 
oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, Index)
    if self == Mouse and not checkcaller() and Toggles.aim_Enabled.Value and Options.Method.Value == "Mouse.Hit/Target" and getClosestPlayer() then
        local HitPart = getClosestPlayer()
         
        if Index == "Target" or Index == "target" then 
            return HitPart
        elseif Index == "Hit" or Index == "hit" then 
            return ((Toggles.Prediction.Value and (HitPart.CFrame + (HitPart.Velocity * PredictionAmount))) or (not Toggles.Prediction.Value and HitPart.CFrame))
        elseif Index == "X" or Index == "x" then 
            return self.X 
        elseif Index == "Y" or Index == "y" then 
            return self.Y 
        elseif Index == "UnitRay" then 
            return Ray.new(self.Origin, (self.Hit - self.Origin).Unit)
        end
    end

    return oldIndex(self, Index)
end))
    end)

Section:NewLabel("Crosshairs")
    Section:NewButton("Green Crosshair", "Toggle = G", function()
        loadstring(game:HttpGet("\104\116\116\112\115\58\47\47\114\97\119\46\103\105\116\104\117\98\117\115\101\114\99\111\110\116\101\110\116\46\99\111\109\47\75\101\111\110\101\71\105\116\104\117\98\47\75\101\111\110\101\71\105\116\104\117\98\47\109\97\105\110\47\87\105\108\100\87\101\115\116\71\114\101\101\110\67\114\111\115\115\104\97\105\114"))()
    end)
    Section:NewButton("Red Crosshair (ISSUES) ", "Toggle = LeftAlt", function()
        -- Custom Crosshair by zzerexx#3970
        getgenv().CrosshairSettings = {
            Color = Color3.fromRGB(255,0,0),
            RainbowColor = false,
            Opacity = 1,
            Length = 10, -- Length of each line
            Thickness = 2, -- Thickness of each line
            Offset = 3, -- Offset from the middle point
            Dot = false, -- not recommended
            FollowCursor = true, -- Crosshair follows the cursor
            HideMouseIcon = false, -- Hides the mouse icon, set to 0 to ignore
            HideGameCrosshair = false, -- Hides the current game's crosshair (if its supported)
            ToggleKey = Enum.KeyCode.RightAlt, -- Toggles crosshair visibility
        } -- v1.2.1
    loadstring(game:HttpGet("https://raw.githubusercontent.com/zzerexx/scripts/main/CustomCrosshair.lua", true))()
    end)
    Section:NewToggle("HideCursor", "RedCrosshair", function(state)
        if state then
            getgenv().CrosshairSettings = {
                Color = Color3.fromRGB(255,0,0),
                RainbowColor = false,
                Opacity = 1,
                Length = 10, -- Length of each line
                Thickness = 2, -- Thickness of each line
                Offset = 3, -- Offset from the middle point
                Dot = false, -- not recommended
                FollowCursor = true, -- Crosshair follows the cursor
                HideMouseIcon = true, -- Hides the mouse icon, set to 0 to ignore
                HideGameCrosshair = false, -- Hides the current game's crosshair (if its supported)
                ToggleKey = Enum.KeyCode.RightAlt, -- Toggles crosshair visibility
            } -- v1.2.1
        else
            getgenv().CrosshairSettings = {
                Color = Color3.fromRGB(255,0,0),
                RainbowColor = false,
                Opacity = 1,
                Length = 10, -- Length of each line
                Thickness = 2, -- Thickness of each line
                Offset = 3, -- Offset from the middle point
                Dot = false, -- not recommended
                FollowCursor = true, -- Crosshair follows the cursor
                HideMouseIcon = false, -- Hides the mouse icon, set to 0 to ignore
                HideGameCrosshair = false, -- Hides the current game's crosshair (if its supported)
                ToggleKey = Enum.KeyCode.RightAlt, -- Toggles crosshair visibility
            } -- v1.2.1
        end
    end)
    Section:NewLabel("Others")
    Section:NewButton("Anti Aim", "You can reset to toggle", function()
        loadstring(game:HttpGet("\104\116\116\112\115\58\47\47\97\112\105\46\117\112\108\111\97\100\46\115\121\115\116\101\109\115\47\112\97\115\116\101\115\47\83\114\69\99\87\106\56\105\102\74\118\86\47\114\97\119",true))()
    end)
    
    
    local Tab = Window:NewTab("Visuals")
    local Section = Tab:NewSection("Solo script")
    Section:NewLabel("Esp")
    Section:NewLabel("WeAreDevs Esp")
    Section:NewToggle("Master toggle", "a", function(state)
        if state then
            _G.WRDESPEnabled = true --Enables the ESP (Defaults to true)
    
    
    --Dont edit below
    
    --Only ever load the script once
    if not _G.WRDESPLoaded then    
        ----[[ First- Load Kiriot ESP Library ]]----
    
        --Settings--
        local ESP = {
            Enabled = false,
            Boxes = true,
            BoxShift = CFrame.new(0,-1.5,0),
            BoxSize = Vector3.new(4,6,0),
            Color = Color3.fromRGB(255, 170, 0),
            FaceCamera = false,
            Names = true,
            TeamColor = true,
            Thickness = 2,
            AttachShift = 1,
            TeamMates = true,
            Players = true,
            
            Objects = setmetatable({}, {__mode="kv"}),
            Overrides = {}
        }
    
        --Declarations--
        local cam = workspace.CurrentCamera
        local plrs = game:GetService("Players")
        local plr = plrs.LocalPlayer
        local mouse = plr:GetMouse()
    
        local V3new = Vector3.new
        local WorldToViewportPoint = cam.WorldToViewportPoint
    
        --Functions--
        local function Draw(obj, props)
            local new = Drawing.new(obj)
            
            props = props or {}
            for i,v in pairs(props) do
                new[i] = v
            end
            return new
        end
    
        function ESP:GetTeam(p)
            local ov = self.Overrides.GetTeam
            if ov then
                return ov(p)
            end
            
            return p and p.Team
        end
    
        function ESP:IsTeamMate(p)
            local ov = self.Overrides.IsTeamMate
            if ov then
                return ov(p)
            end
            
            return self:GetTeam(p) == self:GetTeam(plr)
        end
    
        function ESP:GetColor(obj)
            local ov = self.Overrides.GetColor
            if ov then
                return ov(obj)
            end
            local p = self:GetPlrFromChar(obj)
            return p and self.TeamColor and p.Team and p.Team.TeamColor.Color or self.Color
        end
    
        function ESP:GetPlrFromChar(char)
            local ov = self.Overrides.GetPlrFromChar
            if ov then
                return ov(char)
            end
            
            return plrs:GetPlayerFromCharacter(char)
        end
    
        function ESP:Toggle(bool)
            self.Enabled = bool
            if not bool then
                for i,v in pairs(self.Objects) do
                    if v.Type == "Box" then --fov circle etc
                        if v.Temporary then
                            v:Remove()
                        else
                            for i,v in pairs(v.Components) do
                                v.Visible = false
                            end
                        end
                    end
                end
            end
        end
    
        function ESP:GetBox(obj)
            return self.Objects[obj]
        end
    
        function ESP:AddObjectListener(parent, options)
            local function NewListener(c)
                if type(options.Type) == "string" and c:IsA(options.Type) or options.Type == nil then
                    if type(options.Name) == "string" and c.Name == options.Name or options.Name == nil then
                        if not options.Validator or options.Validator(c) then
                            local box = ESP:Add(c, {
                                PrimaryPart = type(options.PrimaryPart) == "string" and c:WaitForChild(options.PrimaryPart) or type(options.PrimaryPart) == "function" and options.PrimaryPart(c),
                                Color = type(options.Color) == "function" and options.Color(c) or options.Color,
                                ColorDynamic = options.ColorDynamic,
                                Name = type(options.CustomName) == "function" and options.CustomName(c) or options.CustomName,
                                IsEnabled = options.IsEnabled,
                                RenderInNil = options.RenderInNil
                            })
                            --TODO: add a better way of passing options
                            if options.OnAdded then
                                coroutine.wrap(options.OnAdded)(box)
                            end
                        end
                    end
                end
            end
    
            if options.Recursive then
                parent.DescendantAdded:Connect(NewListener)
                for i,v in pairs(parent:GetDescendants()) do
                    coroutine.wrap(NewListener)(v)
                end
            else
                parent.ChildAdded:Connect(NewListener)
                for i,v in pairs(parent:GetChildren()) do
                    coroutine.wrap(NewListener)(v)
                end
            end
        end
    
        local boxBase = {}
        boxBase.__index = boxBase
    
        function boxBase:Remove()
            ESP.Objects[self.Object] = nil
            for i,v in pairs(self.Components) do
                v.Visible = false
                v:Remove()
                self.Components[i] = nil
            end
        end
    
        function boxBase:Update()
            if not self.PrimaryPart then
                --warn("not supposed to print", self.Object)
                return self:Remove()
            end
    
            local color
            if ESP.Highlighted == self.Object then
            color = ESP.HighlightColor
            else
                color = self.Color or self.ColorDynamic and self:ColorDynamic() or ESP:GetColor(self.Object) or ESP.Color
            end
    
            local allow = true
            if ESP.Overrides.UpdateAllow and not ESP.Overrides.UpdateAllow(self) then
                allow = false
            end
            if self.Player and not ESP.TeamMates and ESP:IsTeamMate(self.Player) then
                allow = false
            end
            if self.Player and not ESP.Players then
                allow = false
            end
            if self.IsEnabled and (type(self.IsEnabled) == "string" and not ESP[self.IsEnabled] or type(self.IsEnabled) == "function" and not self:IsEnabled()) then
                allow = false
            end
            if not workspace:IsAncestorOf(self.PrimaryPart) and not self.RenderInNil then
                allow = false
            end
    
            if not allow then
                for i,v in pairs(self.Components) do
                    v.Visible = false
                end
                return
            end
    
            if ESP.Highlighted == self.Object then
                color = ESP.HighlightColor
            end
    
            --calculations--
            local cf = self.PrimaryPart.CFrame
            if ESP.FaceCamera then
                cf = CFrame.new(cf.p, cam.CFrame.p)
            end
            local size = self.Size
            local locs = {
                TopLeft = cf * ESP.BoxShift * CFrame.new(size.X/2,size.Y/2,0),
                TopRight = cf * ESP.BoxShift * CFrame.new(-size.X/2,size.Y/2,0),
                BottomLeft = cf * ESP.BoxShift * CFrame.new(size.X/2,-size.Y/2,0),
                BottomRight = cf * ESP.BoxShift * CFrame.new(-size.X/2,-size.Y/2,0),
                TagPos = cf * ESP.BoxShift * CFrame.new(0,size.Y/2,0),
                Torso = cf * ESP.BoxShift
            }
    
            if ESP.Boxes then
                local TopLeft, Vis1 = WorldToViewportPoint(cam, locs.TopLeft.p)
                local TopRight, Vis2 = WorldToViewportPoint(cam, locs.TopRight.p)
                local BottomLeft, Vis3 = WorldToViewportPoint(cam, locs.BottomLeft.p)
                local BottomRight, Vis4 = WorldToViewportPoint(cam, locs.BottomRight.p)
    
                if self.Components.Quad then
                    if Vis1 or Vis2 or Vis3 or Vis4 then
                        self.Components.Quad.Visible = true
                        self.Components.Quad.PointA = Vector2.new(TopRight.X, TopRight.Y)
                        self.Components.Quad.PointB = Vector2.new(TopLeft.X, TopLeft.Y)
                        self.Components.Quad.PointC = Vector2.new(BottomLeft.X, BottomLeft.Y)
                        self.Components.Quad.PointD = Vector2.new(BottomRight.X, BottomRight.Y)
                        self.Components.Quad.Color = color
                    else
                        self.Components.Quad.Visible = false
                    end
                end
            else
                self.Components.Quad.Visible = false
            end
    
            if ESP.Names then
                local TagPos, Vis5 = WorldToViewportPoint(cam, locs.TagPos.p)
                
                if Vis5 then
                    self.Components.Name.Visible = true
                    self.Components.Name.Position = Vector2.new(TagPos.X, TagPos.Y)
                    self.Components.Name.Text = self.Name
                    self.Components.Name.Color = color
                    
                    self.Components.Distance.Visible = true
                    self.Components.Distance.Position = Vector2.new(TagPos.X, TagPos.Y + 14)
                    self.Components.Distance.Text = math.floor((cam.CFrame.p - cf.p).magnitude) .."m away"
                    self.Components.Distance.Color = color
                else
                    self.Components.Name.Visible = false
                    self.Components.Distance.Visible = false
                end
            else
                self.Components.Name.Visible = false
                self.Components.Distance.Visible = false
            end
            
            if ESP.Tracers then
                local TorsoPos, Vis6 = WorldToViewportPoint(cam, locs.Torso.p)
    
                if Vis6 then
                    self.Components.Tracer.Visible = true
                    self.Components.Tracer.From = Vector2.new(TorsoPos.X, TorsoPos.Y)
                    self.Components.Tracer.To = Vector2.new(cam.ViewportSize.X/2,cam.ViewportSize.Y/ESP.AttachShift)
                    self.Components.Tracer.Color = color
                else
                    self.Components.Tracer.Visible = false
                end
            else
                self.Components.Tracer.Visible = false
            end
        end
    
        function ESP:Add(obj, options)
            if not obj.Parent and not options.RenderInNil then
                return warn(obj, "has no parent")
            end
    
            local box = setmetatable({
                Name = options.Name or obj.Name,
                Type = "Box",
                Color = options.Color --[[or self:GetColor(obj)]],
                Size = options.Size or self.BoxSize,
                Object = obj,
                Player = options.Player or plrs:GetPlayerFromCharacter(obj),
                PrimaryPart = options.PrimaryPart or obj.ClassName == "Model" and (obj.PrimaryPart or obj:FindFirstChild("HumanoidRootPart") or obj:FindFirstChildWhichIsA("BasePart")) or obj:IsA("BasePart") and obj,
                Components = {},
                IsEnabled = options.IsEnabled,
                Temporary = options.Temporary,
                ColorDynamic = options.ColorDynamic,
                RenderInNil = options.RenderInNil
            }, boxBase)
    
            if self:GetBox(obj) then
                self:GetBox(obj):Remove()
            end
    
            box.Components["Quad"] = Draw("Quad", {
                Thickness = self.Thickness,
                Color = color,
                Transparency = 1,
                Filled = false,
                Visible = self.Enabled and self.Boxes
            })
            box.Components["Name"] = Draw("Text", {
                Text = box.Name,
                Color = box.Color,
                Center = true,
                Outline = true,
                Size = 19,
                Visible = self.Enabled and self.Names
            })
            box.Components["Distance"] = Draw("Text", {
                Color = box.Color,
                Center = true,
                Outline = true,
                Size = 19,
                Visible = self.Enabled and self.Names
            })
            
            box.Components["Tracer"] = Draw("Line", {
                Thickness = ESP.Thickness,
                Color = box.Color,
                Transparency = 1,
                Visible = self.Enabled and self.Tracers
            })
            self.Objects[obj] = box
            
            obj.AncestryChanged:Connect(function(_, parent)
                if parent == nil and ESP.AutoRemove ~= false then
                    box:Remove()
                end
            end)
            obj:GetPropertyChangedSignal("Parent"):Connect(function()
                if obj.Parent == nil and ESP.AutoRemove ~= false then
                    box:Remove()
                end
            end)
    
            local hum = obj:FindFirstChildOfClass("Humanoid")
            if hum then
                hum.Died:Connect(function()
                    if ESP.AutoRemove ~= false then
                        box:Remove()
                    end
                end)
            end
    
            return box
        end
    
        local function CharAdded(char)
            local p = plrs:GetPlayerFromCharacter(char)
            if not char:FindFirstChild("HumanoidRootPart") then
                local ev
                ev = char.ChildAdded:Connect(function(c)
                    if c.Name == "HumanoidRootPart" then
                        ev:Disconnect()
                        ESP:Add(char, {
                            Name = p.Name,
                            Player = p,
                            PrimaryPart = c
                        })
                    end
                end)
            else
                ESP:Add(char, {
                    Name = p.Name,
                    Player = p,
                    PrimaryPart = char.HumanoidRootPart
                })
            end
        end
        local function PlayerAdded(p)
            p.CharacterAdded:Connect(CharAdded)
            if p.Character then
                coroutine.wrap(CharAdded)(p.Character)
            end
        end
        plrs.PlayerAdded:Connect(PlayerAdded)
        for i,v in pairs(plrs:GetPlayers()) do
            if v ~= plr then
                PlayerAdded(v)
            end
        end
    
        game:GetService("RunService").RenderStepped:Connect(function()
            cam = workspace.CurrentCamera
            for i,v in (ESP.Enabled and pairs or ipairs)(ESP.Objects) do
                if v.Update then
                    local s,e = pcall(v.Update, v)
                    if not s then warn("[EU]", e, v.Object:GetFullName()) end
                end
            end
        end)
    
        ----[[ Now Begins WRD's modification for implementation ]]----
    
        --Sets defaults where required
        if _G.WRDESPEnabled == nil then _G.WRDESPEnabled = true end
        if _G.WRDESPBoxes == nil then _G.WRDESPBoxes = true end
        if _G.WRDESPTeamColors == nil then _G.WRDESPTeamColors = true end
        if _G.WRDESPTracers == nil then _G.WRDESPTracers = false end
        if _G.WRDESPNames == nil then _G.WRDESPNames = true end
        
        --Hacky way to keep up with setting changes
        while wait(.1) do
            ESP:Toggle(_G.WRDESPEnabled or false)
            ESP.Boxes = _G.WRDESPBoxes or false
            ESP.TeamColors = _G.WRDESPTeamColors or false
            ESP.Tracers = _G.WRDESPTracers or false
            ESP.Names = _G.WRDESPNames or false
        end
    
        _G.WRDESPLoaded = true
    end
        else
            _G.WRDESPEnabled = false --Enables the ESP (Defaults to true)

    
    --Dont edit below
    
    --Only ever load the script once
    if not _G.WRDESPLoaded then    
        ----[[ First- Load Kiriot ESP Library ]]----
    
        --Settings--
        local ESP = {
            Enabled = false,
            Boxes = true,
            BoxShift = CFrame.new(0,-1.5,0),
            BoxSize = Vector3.new(4,6,0),
            Color = Color3.fromRGB(255, 170, 0),
            FaceCamera = false,
            Names = true,
            TeamColor = true,
            Thickness = 2,
            AttachShift = 1,
            TeamMates = true,
            Players = true,
            
            Objects = setmetatable({}, {__mode="kv"}),
            Overrides = {}
        }
    
        --Declarations--
        local cam = workspace.CurrentCamera
        local plrs = game:GetService("Players")
        local plr = plrs.LocalPlayer
        local mouse = plr:GetMouse()
    
        local V3new = Vector3.new
        local WorldToViewportPoint = cam.WorldToViewportPoint
    
        --Functions--
        local function Draw(obj, props)
            local new = Drawing.new(obj)
            
            props = props or {}
            for i,v in pairs(props) do
                new[i] = v
            end
            return new
        end
    
        function ESP:GetTeam(p)
            local ov = self.Overrides.GetTeam
            if ov then
                return ov(p)
            end
            
            return p and p.Team
        end
    
        function ESP:IsTeamMate(p)
            local ov = self.Overrides.IsTeamMate
            if ov then
                return ov(p)
            end
            
            return self:GetTeam(p) == self:GetTeam(plr)
        end
    
        function ESP:GetColor(obj)
            local ov = self.Overrides.GetColor
            if ov then
                return ov(obj)
            end
            local p = self:GetPlrFromChar(obj)
            return p and self.TeamColor and p.Team and p.Team.TeamColor.Color or self.Color
        end
    
        function ESP:GetPlrFromChar(char)
            local ov = self.Overrides.GetPlrFromChar
            if ov then
                return ov(char)
            end
            
            return plrs:GetPlayerFromCharacter(char)
        end
    
        function ESP:Toggle(bool)
            self.Enabled = bool
            if not bool then
                for i,v in pairs(self.Objects) do
                    if v.Type == "Box" then --fov circle etc
                        if v.Temporary then
                            v:Remove()
                        else
                            for i,v in pairs(v.Components) do
                                v.Visible = false
                            end
                        end
                    end
                end
            end
        end
    
        function ESP:GetBox(obj)
            return self.Objects[obj]
        end
    
        function ESP:AddObjectListener(parent, options)
            local function NewListener(c)
                if type(options.Type) == "string" and c:IsA(options.Type) or options.Type == nil then
                    if type(options.Name) == "string" and c.Name == options.Name or options.Name == nil then
                        if not options.Validator or options.Validator(c) then
                            local box = ESP:Add(c, {
                                PrimaryPart = type(options.PrimaryPart) == "string" and c:WaitForChild(options.PrimaryPart) or type(options.PrimaryPart) == "function" and options.PrimaryPart(c),
                                Color = type(options.Color) == "function" and options.Color(c) or options.Color,
                                ColorDynamic = options.ColorDynamic,
                                Name = type(options.CustomName) == "function" and options.CustomName(c) or options.CustomName,
                                IsEnabled = options.IsEnabled,
                                RenderInNil = options.RenderInNil
                            })
                            --TODO: add a better way of passing options
                            if options.OnAdded then
                                coroutine.wrap(options.OnAdded)(box)
                            end
                        end
                    end
                end
            end
    
            if options.Recursive then
                parent.DescendantAdded:Connect(NewListener)
                for i,v in pairs(parent:GetDescendants()) do
                    coroutine.wrap(NewListener)(v)
                end
            else
                parent.ChildAdded:Connect(NewListener)
                for i,v in pairs(parent:GetChildren()) do
                    coroutine.wrap(NewListener)(v)
                end
            end
        end
    
        local boxBase = {}
        boxBase.__index = boxBase
    
        function boxBase:Remove()
            ESP.Objects[self.Object] = nil
            for i,v in pairs(self.Components) do
                v.Visible = false
                v:Remove()
                self.Components[i] = nil
            end
        end
    
        function boxBase:Update()
            if not self.PrimaryPart then
                --warn("not supposed to print", self.Object)
                return self:Remove()
            end
    
            local color
            if ESP.Highlighted == self.Object then
            color = ESP.HighlightColor
            else
                color = self.Color or self.ColorDynamic and self:ColorDynamic() or ESP:GetColor(self.Object) or ESP.Color
            end
    
            local allow = true
            if ESP.Overrides.UpdateAllow and not ESP.Overrides.UpdateAllow(self) then
                allow = false
            end
            if self.Player and not ESP.TeamMates and ESP:IsTeamMate(self.Player) then
                allow = false
            end
            if self.Player and not ESP.Players then
                allow = false
            end
            if self.IsEnabled and (type(self.IsEnabled) == "string" and not ESP[self.IsEnabled] or type(self.IsEnabled) == "function" and not self:IsEnabled()) then
                allow = false
            end
            if not workspace:IsAncestorOf(self.PrimaryPart) and not self.RenderInNil then
                allow = false
            end
    
            if not allow then
                for i,v in pairs(self.Components) do
                    v.Visible = false
                end
                return
            end
    
            if ESP.Highlighted == self.Object then
                color = ESP.HighlightColor
            end
    
            --calculations--
            local cf = self.PrimaryPart.CFrame
            if ESP.FaceCamera then
                cf = CFrame.new(cf.p, cam.CFrame.p)
            end
            local size = self.Size
            local locs = {
                TopLeft = cf * ESP.BoxShift * CFrame.new(size.X/2,size.Y/2,0),
                TopRight = cf * ESP.BoxShift * CFrame.new(-size.X/2,size.Y/2,0),
                BottomLeft = cf * ESP.BoxShift * CFrame.new(size.X/2,-size.Y/2,0),
                BottomRight = cf * ESP.BoxShift * CFrame.new(-size.X/2,-size.Y/2,0),
                TagPos = cf * ESP.BoxShift * CFrame.new(0,size.Y/2,0),
                Torso = cf * ESP.BoxShift
            }
    
            if ESP.Boxes then
                local TopLeft, Vis1 = WorldToViewportPoint(cam, locs.TopLeft.p)
                local TopRight, Vis2 = WorldToViewportPoint(cam, locs.TopRight.p)
                local BottomLeft, Vis3 = WorldToViewportPoint(cam, locs.BottomLeft.p)
                local BottomRight, Vis4 = WorldToViewportPoint(cam, locs.BottomRight.p)
    
                if self.Components.Quad then
                    if Vis1 or Vis2 or Vis3 or Vis4 then
                        self.Components.Quad.Visible = true
                        self.Components.Quad.PointA = Vector2.new(TopRight.X, TopRight.Y)
                        self.Components.Quad.PointB = Vector2.new(TopLeft.X, TopLeft.Y)
                        self.Components.Quad.PointC = Vector2.new(BottomLeft.X, BottomLeft.Y)
                        self.Components.Quad.PointD = Vector2.new(BottomRight.X, BottomRight.Y)
                        self.Components.Quad.Color = color
                    else
                        self.Components.Quad.Visible = false
                    end
                end
            else
                self.Components.Quad.Visible = false
            end
    
            if ESP.Names then
                local TagPos, Vis5 = WorldToViewportPoint(cam, locs.TagPos.p)
                
                if Vis5 then
                    self.Components.Name.Visible = true
                    self.Components.Name.Position = Vector2.new(TagPos.X, TagPos.Y)
                    self.Components.Name.Text = self.Name
                    self.Components.Name.Color = color
                    
                    self.Components.Distance.Visible = true
                    self.Components.Distance.Position = Vector2.new(TagPos.X, TagPos.Y + 14)
                    self.Components.Distance.Text = math.floor((cam.CFrame.p - cf.p).magnitude) .."m away"
                    self.Components.Distance.Color = color
                else
                    self.Components.Name.Visible = false
                    self.Components.Distance.Visible = false
                end
            else
                self.Components.Name.Visible = false
                self.Components.Distance.Visible = false
            end
            
            if ESP.Tracers then
                local TorsoPos, Vis6 = WorldToViewportPoint(cam, locs.Torso.p)
    
                if Vis6 then
                    self.Components.Tracer.Visible = true
                    self.Components.Tracer.From = Vector2.new(TorsoPos.X, TorsoPos.Y)
                    self.Components.Tracer.To = Vector2.new(cam.ViewportSize.X/2,cam.ViewportSize.Y/ESP.AttachShift)
                    self.Components.Tracer.Color = color
                else
                    self.Components.Tracer.Visible = false
                end
            else
                self.Components.Tracer.Visible = false
            end
        end
    
        function ESP:Add(obj, options)
            if not obj.Parent and not options.RenderInNil then
                return warn(obj, "has no parent")
            end
    
            local box = setmetatable({
                Name = options.Name or obj.Name,
                Type = "Box",
                Color = options.Color --[[or self:GetColor(obj)]],
                Size = options.Size or self.BoxSize,
                Object = obj,
                Player = options.Player or plrs:GetPlayerFromCharacter(obj),
                PrimaryPart = options.PrimaryPart or obj.ClassName == "Model" and (obj.PrimaryPart or obj:FindFirstChild("HumanoidRootPart") or obj:FindFirstChildWhichIsA("BasePart")) or obj:IsA("BasePart") and obj,
                Components = {},
                IsEnabled = options.IsEnabled,
                Temporary = options.Temporary,
                ColorDynamic = options.ColorDynamic,
                RenderInNil = options.RenderInNil
            }, boxBase)
    
            if self:GetBox(obj) then
                self:GetBox(obj):Remove()
            end
    
            box.Components["Quad"] = Draw("Quad", {
                Thickness = self.Thickness,
                Color = color,
                Transparency = 1,
                Filled = false,
                Visible = self.Enabled and self.Boxes
            })
            box.Components["Name"] = Draw("Text", {
                Text = box.Name,
                Color = box.Color,
                Center = true,
                Outline = true,
                Size = 19,
                Visible = self.Enabled and self.Names
            })
            box.Components["Distance"] = Draw("Text", {
                Color = box.Color,
                Center = true,
                Outline = true,
                Size = 19,
                Visible = self.Enabled and self.Names
            })
            
            box.Components["Tracer"] = Draw("Line", {
                Thickness = ESP.Thickness,
                Color = box.Color,
                Transparency = 1,
                Visible = self.Enabled and self.Tracers
            })
            self.Objects[obj] = box
            
            obj.AncestryChanged:Connect(function(_, parent)
                if parent == nil and ESP.AutoRemove ~= false then
                    box:Remove()
                end
            end)
            obj:GetPropertyChangedSignal("Parent"):Connect(function()
                if obj.Parent == nil and ESP.AutoRemove ~= false then
                    box:Remove()
                end
            end)
    
            local hum = obj:FindFirstChildOfClass("Humanoid")
            if hum then
                hum.Died:Connect(function()
                    if ESP.AutoRemove ~= false then
                        box:Remove()
                    end
                end)
            end
    
            return box
        end
    
        local function CharAdded(char)
            local p = plrs:GetPlayerFromCharacter(char)
            if not char:FindFirstChild("HumanoidRootPart") then
                local ev
                ev = char.ChildAdded:Connect(function(c)
                    if c.Name == "HumanoidRootPart" then
                        ev:Disconnect()
                        ESP:Add(char, {
                            Name = p.Name,
                            Player = p,
                            PrimaryPart = c
                        })
                    end
                end)
            else
                ESP:Add(char, {
                    Name = p.Name,
                    Player = p,
                    PrimaryPart = char.HumanoidRootPart
                })
            end
        end
        local function PlayerAdded(p)
            p.CharacterAdded:Connect(CharAdded)
            if p.Character then
                coroutine.wrap(CharAdded)(p.Character)
            end
        end
        plrs.PlayerAdded:Connect(PlayerAdded)
        for i,v in pairs(plrs:GetPlayers()) do
            if v ~= plr then
                PlayerAdded(v)
            end
        end
    
        game:GetService("RunService").RenderStepped:Connect(function()
            cam = workspace.CurrentCamera
            for i,v in (ESP.Enabled and pairs or ipairs)(ESP.Objects) do
                if v.Update then
                    local s,e = pcall(v.Update, v)
                    if not s then warn("[EU]", e, v.Object:GetFullName()) end
                end
            end
        end)
    
        ----[[ Now Begins WRD's modification for implementation ]]----
    
        --Sets defaults where required
        if _G.WRDESPEnabled == nil then _G.WRDESPEnabled = true end
        if _G.WRDESPBoxes == nil then _G.WRDESPBoxes = true end
        if _G.WRDESPTeamColors == nil then _G.WRDESPTeamColors = true end
        if _G.WRDESPTracers == nil then _G.WRDESPTracers = false end
        if _G.WRDESPNames == nil then _G.WRDESPNames = true end
        
        --Hacky way to keep up with setting changes
        while wait(.1) do
            ESP:Toggle(_G.WRDESPEnabled or false)
            ESP.Boxes = _G.WRDESPBoxes or false
            ESP.TeamColors = _G.WRDESPTeamColors or false
            ESP.Tracers = _G.WRDESPTracers or false
            ESP.Names = _G.WRDESPNames or false
        end
    
        _G.WRDESPLoaded = true
    end
        end
    end)
    Section:NewToggle("Boxes", "a", function(state)
        if state then
            _G.WRDESPBoxes = true
        else
            _G.WRDESPBoxes = false
        end
    end)
    Section:NewToggle("TeamColors", "b", function(state)
        if state then
            _G.WRDESPTeamColors = true
        else
            _G.WRDESPTeamColors = false
        end
    end)
    Section:NewToggle("Tracers", "c", function(state)
        if state then
            _G.WRDESPTracers = true
        else
            _G.WRDESPTracers = false
        end
    end)
    Section:NewToggle("Names", "d", function(state)
        if state then
            _G.WRDESPNames = true
        else
            _G.WRDESPNames = false
        end
    end)
    Section:NewLabel("Random ESP")
    Section:NewButton("Chams with glow ESP (ISSUES)", "Its like a wallhack", function()
    local dwEntities = game:GetService("Players")
    local dwLocalPlayer = dwEntities.LocalPlayer 
    local dwRunService = game:GetService("RunService")
    
    local settings_tbl = {
        ESP_Enabled = true,
        ESP_TeamCheck = false,
        Chams = true,
        Chams_Color = Color3.fromRGB(0, 255, 0),
        Chams_Transparency = 0.4,
        Chams_Glow_Color = Color3.fromRGB(255,0,0)
    }
    
    function destroy_chams(char)
    
        for k,v in next, char:GetChildren() do 
    
            if v:IsA("BasePart") and v.Transparency ~= 1 then
    
                if v:FindFirstChild("Glow") and 
                v:FindFirstChild("Chams") then
    
                    v.Glow:Destroy()
                    v.Chams:Destroy() 
    
                end 
    
            end 
    
        end 
    
    end
    
    dwRunService.Heartbeat:Connect(function()
    
        if settings_tbl.ESP_Enabled then
    
            for k,v in next, dwEntities:GetPlayers() do 
    
                if v ~= dwLocalPlayer then
    
                    if v.Character and
                    v.Character:FindFirstChild("HumanoidRootPart") and 
                    v.Character:FindFirstChild("Humanoid") and 
                    v.Character:FindFirstChild("Humanoid").Health ~= 0 then
    
                        if settings_tbl.ESP_TeamCheck == false then
    
                            local char = v.Character 
    
                            for k,b in next, char:GetChildren() do 
    
                                if b:IsA("BasePart") and 
                                b.Transparency ~= 1 then
                                    
                                    if settings_tbl.Chams then
    
                                        if not b:FindFirstChild("Glow") and
                                        not b:FindFirstChild("Chams") then
    
                                            local chams_box = Instance.new("BoxHandleAdornment", b)
                                            chams_box.Name = "Chams"
                                            chams_box.AlwaysOnTop = true 
                                            chams_box.ZIndex = 4 
                                            chams_box.Adornee = b 
                                            chams_box.Color3 = settings_tbl.Chams_Color
                                            chams_box.Transparency = settings_tbl.Chams_Transparency
                                            chams_box.Size = b.Size + Vector3.new(0.02, 0.02, 0.02)
    
                                            local glow_box = Instance.new("BoxHandleAdornment", b)
                                            glow_box.Name = "Glow"
                                            glow_box.AlwaysOnTop = false 
                                            glow_box.ZIndex = 3 
                                            glow_box.Adornee = b 
                                            glow_box.Color3 = settings_tbl.Chams_Glow_Color
                                            glow_box.Size = chams_box.Size + Vector3.new(0.13, 0.13, 0.13)
    
                                        end
    
                                    else
    
                                        destroy_chams(char)
    
                                    end
                                
                                end
    
                            end
    
                        else
    
                            if v.Team == dwLocalPlayer.Team then
                                destroy_chams(v.Character)
                            end
    
                        end
    
                    else
    
                        destroy_chams(v.Character)
    
                    end
    
                end
    
            end
    
        else 
    
            for k,v in next, dwEntities:GetPlayers() do 
    
                if v ~= dwLocalPlayer and 
                v.Character and 
                v.Character:FindFirstChild("HumanoidRootPart") and 
                v.Character:FindFirstChild("Humanoid") and 
                v.Character:FindFirstChild("Humanoid").Health ~= 0 then
                    
                    destroy_chams(v.Character)
    
                end
    
            end
    
        end
    
    end)
end)

Section:NewButton("Skeleton Esp", "Just esp for the skeleton of anybody", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/TheNuggetEater05/ekaMiffutSmodnaR/main/GlobalR6SkeletonESP.lua"))()

shared.BoneESP_Settings = {
    Circle_Visible = true,
    Circle_Radius = 10,
    BoneESP_Color = Color3.fromRGB(255,0,0)
}
end)

Section:NewLabel("Visuals")
    Section:NewButton("Clear Fog", "delete fog from game", function()
        game.Lighting.Atmosphere:Destroy() game.Lighting.DepthOfField:Destroy() game.Lighting.FogStart = 1e20 game.Lighting.FogEnd = 1e20
    end)
    Section:NewToggle("Full bright", "Great for the night", function(state)
        if state then
            loadstring(game:HttpGet("https://pastebin.com/raw/13fxDjAY", true))()
        else
            loadstring(game:HttpGet("https://pastebin.com/raw/13fxDjAY", true))()
        end
    end)
    Section:NewButton("KeyStrokes", "Its a very good keystrokes", function()
        loadstring(game:HttpGet("https://system-exodus.com/scripts/misc-releases/Keystrokes.lua",true))()
    end)
    

local Tab = Window:NewTab("Misc")
local Section = Tab:NewSection("Solo script")
Section:NewButton("Chat Spy", "With this you can turn on chat", function()
    loadstring(game:HttpGet('https://cdn.y2k06.xyz/lua/SpyChat.lua', true))()
end)
Section:NewButton("bruh", "Changue Sky and more", function()
    loadstring(game:HttpGet("\104\116\116\112\115\58\47\47\114\97\119\46\103\105\116\104\117\98\117\115\101\114\99\111\110\116\101\110\116\46\99\111\109\47\75\101\111\110\101\71\105\116\104\117\98\83\112\97\109\47\75\101\111\110\101\71\105\116\104\117\98\83\112\97\109\47\109\97\105\110\47\78\97\117\103\104\116\121\78\97\117\103\104\116\121\47\68\101\99\97\108\115"))()
end)
Section:NewButton("Server Hop", "If you click this you automatic go to other server", function()
    loadstring(game:HttpGet("\104\116\116\112\115\58\47\47\112\97\115\116\101\98\105\110\46\99\111\109\47\114\97\119\47\86\100\117\66\84\50\110\116"))()
end)
Section:NewButton("Remove textures | Fps boost", "", function()
    loadstring(game:HttpGet("\104\116\116\112\115\58\47\47\114\97\119\46\103\105\116\104\117\98\117\115\101\114\99\111\110\116\101\110\116\46\99\111\109\47\75\101\111\110\101\71\105\116\104\117\98\83\112\97\109\47\75\101\111\110\101\71\105\116\104\117\98\83\112\97\109\47\109\97\105\110\47\70\112\115\66\111\111\115\116\84\101\120\116\117\114\101"))()
end)
Section:NewButton("Spin + noclip | Reset to stop", "Nothing", function()
    loadstring(game:HttpGet("\104\116\116\112\115\58\47\47\112\97\115\116\101\98\105\110\46\99\111\109\47\114\97\119\47\87\86\50\117\114\90\85\119"))()
end)
Section:NewButton("Max Zoom", "", function()
    loadstring(game:HttpGet("\104\116\116\112\115\58\47\47\114\97\119\46\103\105\116\104\117\98\117\115\101\114\99\111\110\116\101\110\116\46\99\111\109\47\75\101\111\110\101\71\105\116\104\117\98\83\112\97\109\47\75\101\111\110\101\71\105\116\104\117\98\83\112\97\109\47\109\97\105\110\47\77\97\120\90\111\111\109\47\76\69\83\83\71\79\79\90\79\79\77"))()
end)
Section:NewButton("Free cam", "Press SHITF+P For turn on", function()
    loadstring(game:HttpGet("https://pastebin.com/raw/ct8Kq5F0", true))()
end)

local Tab = Window:NewTab("Guis+Hubs")
local Section = Tab:NewSection("Hubs!")
Section:NewButton("Owl Hub", "Great Hub with Aimbot and Esp", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/CriShoux/OwlHub/master/OwlHub.txt", true))()
end)
Section:NewButton("Utility GUI", "Modified by solo script (made by ???)", function()
    local ui = loadstring(game:HttpGet('https://raw.githubusercontent.com/BoaHacker/ROBLOX/main/ui', true))()

local player = game.Players.LocalPlayer
local mouse = player:GetMouse()
local antiAFK = true
player.Idled:connect(function()
	if antiAFK then
		game.VirtualUser:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
		wait(1)
		game.VirtualUser:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
	end
end)

local Player = ui:CreateWindow({
	text = 'Utility'
})

local Settings = ui:CreateWindow({
	text = 'Destroy'
})

Player:AddToggle('Infinite Jump', function(state)
	getgenv().InfiniteJump = state
	game.UserInputService.JumpRequest:connect(function()
		if not getgenv().InfiniteJump then return end
		player.Character.Humanoid:ChangeState('Jumping')
	end)
end)
Player:AddToggle('Click to TP', function(state)
	getgenv().ClicktoTP = state
	mouse.Button1Down:Connect(function()
		if not getgenv().ClicktoTP then return end
		player.Character.HumanoidRootPart.CFrame = CFrame.new(mouse.Hit.x, mouse.Hit.y + 5, mouse.Hit.z) * CFrame.Angles(0, math.rad(player.Character.HumanoidRootPart.Orientation.Y), 0)
	end)
end)



Player:AddToggle('Noclip', function(state)
	getgenv().Noclip = state
	while true do
		if not getgenv().Noclip then return end
		game.RunService.Stepped:wait()
		for i, v in pairs(player.Character:GetDescendants()) do
			if v:IsA('BasePart') then
				v.CanCollide = false
			end
		end
	end
end)
for i, v in pairs(workspace:GetChildren()) do
	if v.Name == 'Core' then
		v:Destroy()
	end
end
local Core = Instance.new('Part', workspace)
Core.Name = 'Core'
Core.Size = Vector3.new(0.05, 0.05, 0.05)
Core.CanCollide = false
workspace:WaitForChild('Core')
local torso = workspace.Core
local speed = 10
local keys = {a = false, d = false, w = false, s = false}
local e1
local e2
local function Fly()
	local pos = Instance.new('BodyPosition', torso)
	local gyro = Instance.new('BodyGyro', torso)
	pos.maxForce = Vector3.new(math.huge, math.huge, math.huge)
	pos.position = torso.Position
	gyro.maxTorque = Vector3.new(9e9, 9e9, 9e9)
	gyro.cframe = torso.CFrame
	repeat
		wait()
		player.Character.Humanoid.PlatformStand = true
		local new = gyro.cframe - gyro.cframe.p + pos.position
		if not keys.w and not keys.s and not keys.a and not keys.d then
			speed = 5
		end
		if keys.w then
			new = new + workspace.CurrentCamera.CoordinateFrame.lookVector * speed
			speed = speed + 0
		end
		if keys.s then
			new = new - workspace.CurrentCamera.CoordinateFrame.lookVector * speed
			speed = speed + 0
		end
		if keys.d then
			new = new * CFrame.new(speed, 0, 0)
			speed = speed + 0
		end
		if keys.a then
			new = new * CFrame.new(-speed, 0, 0)
			speed = speed + 0
		end
		if speed > 10 then
			speed = 5
		end
		pos.position = new.p
		if keys.w then
			gyro.cframe = workspace.CurrentCamera.CoordinateFrame * CFrame.Angles(-math.rad(speed * 0), 0, 0)
		elseif keys.s then
			gyro.cframe = workspace.CurrentCamera.CoordinateFrame * CFrame.Angles(math.rad(speed * 0), 0, 0)
		else
			gyro.cframe = workspace.CurrentCamera.CoordinateFrame
		end
	until getgenv().Fly == false
	if gyro then gyro:Destroy() end
	if pos then pos:Destroy() end
	player.Character.Humanoid.PlatformStand = false
	speed = 10
end
e1 = mouse.KeyDown:connect(function(key)
	if not torso or not torso.Parent then e1:disconnect() e2:disconnect() return end
	if key == 'w' then
		keys.w = true
	elseif key == 's' then
		keys.s = true
	elseif key == 'a' then
		keys.a = true
	elseif key == 'd' then
		keys.d = true
	end
end)
e2 = mouse.KeyUp:connect(function(key)
	if key == 'w' then
		keys.w = false
	elseif key == 's' then
		keys.s = false
	elseif key == 'a' then
		keys.a = false
	elseif key == 'd' then
		keys.d = false
	end
end)
Player:AddToggle('Fly', function(state)
	getgenv().Fly = state
	if not getgenv().Fly then for i, v in pairs(workspace:FindFirstChild('Core'):GetChildren()) do v:Destroy() end return end
	local Weld = Instance.new('Weld', Core)
	Weld.Part0 = Core
	Weld.Part1 = player.Character.HumanoidRootPart
	Weld.C0 = CFrame.new(0, 0, 0)
	Fly()
end)



Player:AddBox('Walkspeed', function(state)
	if tonumber(state.Text) ~= nil then
		player.Character.Humanoid.WalkSpeed = state.Text
	end
end)

Player:AddBox('Jumppower', function(state)
	if tonumber(state.Text) ~= nil then
		if player.Character.Humanoid.UseJumpPower == true then
			player.Character.Humanoid.JumpPower = state.Text
		else
			player.Character.Humanoid.JumpHeight = state.Text
		end
	end
end)

Player:AddBox('Gravity', function(state)
	if tonumber(state.Text) ~= nil then
		workspace.Gravity = state.Text
	end
end)

Player:AddButton('Reset to Default', function()
	player.Character.Humanoid.WalkSpeed = 16
	if player.Character.Humanoid.UseJumpPower == true then
		player.Character.Humanoid.JumpPower = 50
	else
		player.Character.Humanoid.JumpHeight = 7.2
	end
	player.Character.Humanoid.JumpPower = 50
	workspace.Gravity = 196.2
end)

Settings:AddButton('Destroy gui xD', function()
	ui.gui:Destroy()
	antiAFK = false
	getgenv().InfiniteJump = false
	getgenv().ClicktoTP = false
	getgenv().Noclip = false
	getgenv().Fly = false
	player.Character.Humanoid.WalkSpeed = 16
	if player.Character.Humanoid.UseJumpPower == true then
		player.Character.Humanoid.JumpPower = 50
	else
		player.Character.Humanoid.JumpHeight = 7.2
	end
	workspace.Gravity = 196.2
end)
end)


local Tab = Window:NewTab("Fly")
local Section = Tab:NewSection("Solo script")
-- SETUP 1
_G.FlySpeed = 50
_G.FlySpeeed3 = 50
if _G.Setup then
else
    _G.Setup = true
end

-- UI And Fly Functions
Section:NewButton("CFRAME FLY (KeyBind 'G')", "Make Player Fly (KeyBind = G)!", function()
    spawn(function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/LegitH3x0R/Roblox-Scripts/main/AEBypassing/RootAnchor.lua"))()

        local UIS = game:GetService("UserInputService")
        local OnRender = game:GetService("RunService").RenderStepped
        
        local Player = game:GetService("Players").LocalPlayer
        local Character = Player.Character or Player.CharacterAdded:Wait()
        
        local Camera = workspace.CurrentCamera
        local Root = Character:WaitForChild("HumanoidRootPart")
        local C1, C2, C3;
        local Nav = {Flying = false, Forward = false, Backward = false, Left = false, Right = false}
        C1 = UIS.InputBegan:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.Keyboard then
                if Input.KeyCode == Enum.KeyCode.G then
                    Nav.Flying = not Nav.Flying
                    Root.Anchored = Nav.Flying
                elseif Input.KeyCode == Enum.KeyCode.W then
                    Nav.Forward = true
                elseif Input.KeyCode == Enum.KeyCode.S then
                    Nav.Backward = true
                elseif Input.KeyCode == Enum.KeyCode.A then
                    Nav.Left = true
                elseif Input.KeyCode == Enum.KeyCode.D then
                    Nav.Right = true
                end
            end
        end)
        
        C2 = UIS.InputEnded:Connect(function(Input)
            if Input.UserInputType == Enum.UserInputType.Keyboard then
                if Input.KeyCode == Enum.KeyCode.W then
                    Nav.Forward = false
                elseif Input.KeyCode == Enum.KeyCode.S then
                    Nav.Backward = false
                elseif Input.KeyCode == Enum.KeyCode.A then
                    Nav.Left = false
                elseif Input.KeyCode == Enum.KeyCode.D then
                    Nav.Right = false
                end
            end
        end)
        
        C3 = Camera:GetPropertyChangedSignal("CFrame"):Connect(function()
            if Nav.Flying then
                Root.CFrame = CFrame.new(Root.CFrame.Position, Root.CFrame.Position + Camera.CFrame.LookVector)
            end
        end)
        
        while true do
            local Delta = OnRender:Wait()
            if Nav.Flying then
                if Nav.Forward then
                    Root.CFrame = Root.CFrame + (Camera.CFrame.LookVector * (Delta * _G.FlySpeed))
                end
                if Nav.Backward then
                    Root.CFrame = Root.CFrame + (-Camera.CFrame.LookVector * (Delta * _G.FlySpeed))
                end
                if Nav.Left then
                    Root.CFrame = Root.CFrame + (-Camera.CFrame.RightVector * (Delta * _G.FlySpeed))
                end
                if Nav.Right then
                    Root.CFrame = Root.CFrame + (Camera.CFrame.RightVector * (Delta * _G.FlySpeed))
                end
            end
        end
    end)
end)

Section:NewSlider("CFrame Fly Speed", "Speed of the CFrame Fly!", 250, 10, function(s) -- 250 (MaxValue) | 0 (MinValue)
    _G.FlySpeed = s
end)
Section:NewLabel("========================================")
Section:NewSlider("Fly Speed", "Speed of the Fly and noclip gui", 250, 10, function(s) -- 250 (MaxValue) | 0 (MinValue)
    _G.Fly = s
end)
Section:NewSlider("NoclipFly Speed", "Speed of the CFrame Fly!", 250, 10, function(s) -- 250 (MaxValue) | 0 (MinValue)
    _G.NoclipFly = s
end)
Section:NewButton("Fly and noclip gui", "Modified by Solo script", function()
   local ScreenGui = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local TextLabel = Instance.new("TextLabel")
local TextLabel_2 = Instance.new("TextLabel")
local TextButton = Instance.new("TextButton")
local TextButton_2 = Instance.new("TextButton")

--Properties:

ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

Frame.Parent = ScreenGui
Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Frame.Position = UDim2.new(0.0833889246, 0, 0.562569201, 0)
Frame.Size = UDim2.new(0, 309, 0, 244)

TextLabel.Parent = Frame
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
TextLabel.Position = UDim2.new(-0.00203825813, 0, -0.00307051861, 0)
TextLabel.Size = UDim2.new(0, 309, 0, 25)
TextLabel.Font = Enum.Font.SourceSans
TextLabel.Text = "Fly and noclip Gui"
TextLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
TextLabel.TextScaled = true
TextLabel.TextSize = 14.000
TextLabel.TextWrapped = true

TextLabel_2.Parent = Frame
TextLabel_2.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
TextLabel_2.Position = UDim2.new(-0.00203825813, 0, 0.894470453, 0)
TextLabel_2.Size = UDim2.new(0, 309, 0, 25)
TextLabel_2.Font = Enum.Font.SourceSans
TextLabel_2.Text = "Modified by Solo Script"
TextLabel_2.TextColor3 = Color3.fromRGB(0, 0, 0)
TextLabel_2.TextScaled = true
TextLabel_2.TextSize = 14.000
TextLabel_2.TextWrapped = true

TextButton.Parent = Frame
TextButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
TextButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextButton.Position = UDim2.new(0.588996768, 0, 0.279716104, 0)
TextButton.Size = UDim2.new(0.369741112, 0, 0.433398396, 0)
TextButton.Font = Enum.Font.SourceSans
TextButton.Text = "Fly"
TextButton.TextColor3 = Color3.fromRGB(255, 255, 255)
TextButton.TextScaled = true
TextButton.TextSize = 14.000
TextButton.TextStrokeTransparency = 0.000
TextButton.TextWrapped = true

TextButton_2.Parent = Frame
TextButton_2.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
TextButton_2.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextButton_2.Position = UDim2.new(0.0622977614, 0, 0.28381446, 0)
TextButton_2.Size = UDim2.new(0.372168273, 0, 0.429300278, 0)
TextButton_2.Font = Enum.Font.SourceSans
TextButton_2.Text = "Noclip+fly"
TextButton_2.TextColor3 = Color3.fromRGB(255, 255, 255)
TextButton_2.TextScaled = true
TextButton_2.TextSize = 14.000
TextButton_2.TextStrokeTransparency = 0.000
TextButton_2.TextWrapped = true

-- Scripts:

local function INDYFQN_fake_script() -- Frame.GuiDrag 
	local script = Instance.new('LocalScript', Frame)

	local 	Frame = script.Parent.Parent.Frame
	
	Frame.Draggable = true
	Frame.Active = true
	
	
	
end
coroutine.wrap(INDYFQN_fake_script)()
local function TZCHT_fake_script() -- TextButton.LocalScript 
	local script = Instance.new('LocalScript', TextButton)

	local keys = {
		LeftShift = false,
	}
	game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(key)
		if key == "0" then
			keys.LeftShift = true
		end
	end)
	game.Players.LocalPlayer:GetMouse().KeyUp:Connect(function(key)
		if key == "0" then
			keys.LeftShift = false
		end
	end)
	local hack = false
	script.Parent.MouseButton1Click:Connect(function()
		hack = not hack
		if hack then
			script.Parent.Text = "Fly"
			script.Parent.BackgroundColor3 = Color3.fromRGB(0,255,0)
			local humanoid = nil
			while hack do
				local fps = game["Run Service"].RenderStepped:Wait()
				if not humanoid or not humanoid.Parent or not humanoid.Parent.Parent then
					if game.Players.LocalPlayer.Character then
						if game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
							humanoid = game.Players.LocalPlayer.Character.Humanoid
							humanoid.PlatformStand = true
						end
					end
				else
					humanoid.PlatformStand = true
					if humanoid.RootPart then
						if humanoid.RootPart:FindFirstChild("NoGravity") then
							humanoid.RootPart.NoGravity.Force = Vector3.new(0,workspace.Gravity*humanoid.RootPart.AssemblyMass,0)
						else
							local no = Instance.new("BodyForce",humanoid.RootPart)
							no.Name = "NoGravity"
							no.Force = Vector3.new(0,workspace.Gravity*humanoid.RootPart.AssemblyMass,0)
						end
						local vel = humanoid.MoveDirection*humanoid.WalkSpeed
						if humanoid.Jump then
							vel = vel+Vector3.new(0,humanoid.WalkSpeed,0)
						end
						if keys.LeftShift then
							vel = vel+Vector3.new(0,-humanoid.WalkSpeed,0)
						end
						humanoid.RootPart.Velocity = ((humanoid.RootPart.Velocity-vel)*(0.75^(30/(1/fps))))+vel
                        getgenv().WalkSpeedValue = _G.Fly; -- Cambia el 100 por el valor que quieras
local Player = game:service'Players'.LocalPlayer;
Player.Character.Humanoid:GetPropertyChangedSignal'WalkSpeed':Connect(function()
Player.Character.Humanoid.WalkSpeed = getgenv().WalkSpeedValue;
end)
Player.Character.Humanoid.WalkSpeed = getgenv().WalkSpeedValue;
					end
				end
			end
		else
			script.Parent.Text = "Fly"
			script.Parent.BackgroundColor3 = Color3.fromRGB(255,0,0)
			game["Run Service"].RenderStepped:Wait()
			game["Run Service"].RenderStepped:Wait()
			if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
				game.Players.LocalPlayer.Character.Humanoid.PlatformStand = false
				if game.Players.LocalPlayer.Character.Humanoid.RootPart and game.Players.LocalPlayer.Character.Humanoid.RootPart:FindFirstChild("NoGravity") then
					game.Players.LocalPlayer.Character.Humanoid.RootPart.NoGravity:Destroy()
                    getgenv().WalkSpeedValue = 16; -- Cambia el 100 por el valor que quieras
local Player = game:service'Players'.LocalPlayer;
Player.Character.Humanoid:GetPropertyChangedSignal'WalkSpeed':Connect(function()
Player.Character.Humanoid.WalkSpeed = getgenv().WalkSpeedValue;
end)
Player.Character.Humanoid.WalkSpeed = getgenv().WalkSpeedValue;
				end
			end
		end
	end)
end
coroutine.wrap(TZCHT_fake_script)()
local function WYLWY_fake_script() -- TextButton_2.LocalScript 
	local script = Instance.new('LocalScript', TextButton_2)

	local keys = {
		LeftShift = false,
	}
	game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(key)
		if key == "0" then
			keys.LeftShift = true
		end
	end)
	game.Players.LocalPlayer:GetMouse().KeyUp:Connect(function(key)
		if key == "0" then
			keys.LeftShift = false
		end
	end)
	local hack = false
	script.Parent.MouseButton1Click:Connect(function()
		hack = not hack
		if hack then
			script.Parent.Text = "Noclip+fly"
			script.Parent.BackgroundColor3 = Color3.fromRGB(0,255,0)
			local humanoid = nil
			while hack do
				local fps = game["Run Service"].RenderStepped:Wait()
				if not humanoid or not humanoid.Parent or not humanoid.Parent.Parent then
					if game.Players.LocalPlayer.Character then
						if game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
							humanoid = game.Players.LocalPlayer.Character.Humanoid
							if humanoid.RootPart then
								humanoid.RootPart.Anchored = true
                                getgenv().WalkSpeedValue = _G.NoclipFly; -- Cambia el 100 por el valor que quieras
local Player = game:service'Players'.LocalPlayer;
Player.Character.Humanoid:GetPropertyChangedSignal'WalkSpeed':Connect(function()
Player.Character.Humanoid.WalkSpeed = getgenv().WalkSpeedValue;
end)
Player.Character.Humanoid.WalkSpeed = getgenv().WalkSpeedValue;
							end
						end
					end
				else
					if humanoid.RootPart then
						humanoid.RootPart.Anchored = true
						local vel = humanoid.MoveDirection*humanoid.WalkSpeed
						if humanoid.Jump then
							vel = vel+Vector3.new(0,humanoid.WalkSpeed,0)
						end
						if keys.LeftShift then
							vel = vel+Vector3.new(0,-humanoid.WalkSpeed,0)
						end
						humanoid.RootPart.Velocity = ((humanoid.RootPart.Velocity-vel)*(0.75^(30/(1/fps))))+vel
						humanoid.RootPart.CFrame = (humanoid.RootPart.CFrame+(humanoid.RootPart.Velocity*fps))*CFrame.Angles(humanoid.RootPart.RotVelocity.X*fps,humanoid.RootPart.RotVelocity.Y*fps,humanoid.RootPart.RotVelocity.Z*fps)
					end
				end
			end
		else
			script.Parent.Text = "Noclip+fly"
			script.Parent.BackgroundColor3 = Color3.fromRGB(255,0,0)
			game["Run Service"].RenderStepped:Wait()
			game["Run Service"].RenderStepped:Wait()
			if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") and game.Players.LocalPlayer.Character.Humanoid.RootPart then
				game.Players.LocalPlayer.Character.Humanoid.RootPart.Anchored = false
                getgenv().WalkSpeedValue = 16; -- Cambia el 100 por el valor que quieras
local Player = game:service'Players'.LocalPlayer;
Player.Character.Humanoid:GetPropertyChangedSignal'WalkSpeed':Connect(function()
Player.Character.Humanoid.WalkSpeed = getgenv().WalkSpeedValue;
end)
Player.Character.Humanoid.WalkSpeed = getgenv().WalkSpeedValue;
			end
		end
	end)
end
coroutine.wrap(WYLWY_fake_script)()
local function XFAYFBB_fake_script() -- ScreenGui.GuiDrag 
	local script = Instance.new('LocalScript', ScreenGui)

	local gui = script.Parent.Parent.Frame --Change this on your mainFrame
	
	Frame.Draggable = true
	Frame.Active = true
	
end
coroutine.wrap(XFAYFBB_fake_script)()
end)
Section:NewLabel("========================================")
Section:NewButton("Fly | (Not recommended fly)", "Press Z to toggle", function()
    loadstring(game:HttpGet("\104\116\116\112\115\58\47\47\114\97\119\46\103\105\116\104\117\98\117\115\101\114\99\111\110\116\101\110\116\46\99\111\109\47\75\101\111\110\101\71\105\116\104\117\98\83\112\97\109\47\75\101\111\110\101\71\105\116\104\117\98\83\112\97\109\47\109\97\105\110\47\70\108\121\47\72\111\114\115\101\102\108\121\47\90\122\122"))()
end)
Section:NewLabel("========================================")
Section:NewSlider("Op Start Fly Speed", "Speed of the OP Fly!", 300, 10, function(s) -- 250 (MaxValue) | 0 (MinValue)
    _G.FlySpeeed3 = s
end)


Section:NewButton("Op Fly", "Press ? to toggle", function()
    -- Bring to you by 7alexv7
-- Enjoy the script!

-- Instances:

local FlyGui = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local TextButton = Instance.new("TextButton")
local TextLabel = Instance.new("TextLabel")

--Properties:

FlyGui.Name = "FlyGui"
FlyGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

Frame.Parent = FlyGui
Frame.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(0.0685602352, 0, 0.168769717, 0)
Frame.Size = UDim2.new(0.264544547, 0, 0.100000024, 0)

TextButton.Parent = Frame
TextButton.BackgroundColor3 = Color3.fromRGB(66, 66, 66)
TextButton.BorderSizePixel = 0
TextButton.Position = UDim2.new(0.06324628, 0, 0.400667697, 0)
TextButton.Size = UDim2.new(0.871157169, 0, 0.495614201, 0)
TextButton.Font = Enum.Font.ArialBold
TextButton.Text = "Fly"
TextButton.TextColor3 = Color3.fromRGB(255, 255, 255)
TextButton.TextScaled = true
TextButton.TextSize = 14.000
TextButton.TextStrokeTransparency = 0.000
TextButton.TextWrapped = true

TextLabel.Parent = Frame
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.Size = UDim2.new(0, 86, 0, 24)
TextLabel.Font = Enum.Font.Oswald
TextLabel.Text = "Robbed XD"
TextLabel.TextColor3 = Color3.fromRGB(255, 0, 255)
TextLabel.TextScaled = true
TextLabel.TextSize = 14.000
TextLabel.TextWrapped = true

-- Scripts:

local function NQWSTGE_fake_script() -- Frame.Fly 
	local script = Instance.new('LocalScript', Frame)

	local plr = script.Parent.Parent.Parent.Parent
	repeat wait() until plr and plr.Character and plr.Character:findFirstChild("HumanoidRootPart") and plr.Character:findFirstChild("Humanoid") 
	local mouse = game.Players.LocalPlayer:GetMouse()  
	repeat wait() until mouse
	
	local torso = plr.Character.HumanoidRootPart 
	local flying = false
	local deb = true 
	local ctrl = {f = 0, b = 0, l = 0, r = 0} 
	local lastctrl = {f = 0, b = 0, l = 0, r = 0} 
	local maxspeed = _G.FlySpeeed3
	local speed = _G.FlySpeeed3
	function Fly() 
	local bg = Instance.new("BodyGyro", torso) 
	bg.P = 9e4 
	bg.maxTorque = Vector3.new(9e9, 9e9, 9e9) 
	bg.cframe = torso.CFrame 
	local bv = Instance.new("BodyVelocity", torso) 
	bv.velocity = Vector3.new(0,0.1,0) 
	bv.maxForce = Vector3.new(9e9, 9e9, 9e9) 
	repeat wait() 
	plr.Character.Humanoid.PlatformStand = true 
	if ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0 then 
	speed = speed+.5+(speed/maxspeed) 
	if speed > maxspeed then 
	speed = maxspeed 
	end 
	elseif not (ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0) and speed ~= 0 then 
	speed = speed-1 
	if speed < 0 then 
					speed = 0
				else
					speed = _G.FlySpeeed3
	end 
	end 
	if (ctrl.l + ctrl.r) ~= 0 or (ctrl.f + ctrl.b) ~= 0 then 
	bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (ctrl.f+ctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(ctrl.l+ctrl.r,(ctrl.f+ctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed 
	lastctrl = {f = ctrl.f, b = ctrl.b, l = ctrl.l, r = ctrl.r} 
	elseif (ctrl.l + ctrl.r) == 0 and (ctrl.f + ctrl.b) == 0 and speed ~= 0 then 
	bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (lastctrl.f+lastctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(lastctrl.l+lastctrl.r,(lastctrl.f+lastctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed 
	else 
	bv.velocity = Vector3.new(0,0.1,0) 
	end 
	bg.cframe = game.Workspace.CurrentCamera.CoordinateFrame * CFrame.Angles(-math.rad((ctrl.f+ctrl.b)*50*speed/maxspeed),0,0) 
	until not flying 
	ctrl = {f = 0, b = 0, l = 0, r = 0} 
	lastctrl = {f = 0, b = 0, l = 0, r = 0} 
		
	bg:Destroy() 
	bv:Destroy() 
		plr.Character.Humanoid.PlatformStand = false 
		speed = _G.FlySpeeed3
	end 
	
	mouse.KeyDown:connect(function(key) 
	if key:lower() == "e" then 
			if flying then flying = false 
				speed = _G.FlySpeeed3
	else 
	flying = true 
	Fly()
	
	end 
	elseif key:lower() == "w" then 
	ctrl.f = 1 
	elseif key:lower() == "s" then 
	ctrl.b = -1 
	elseif key:lower() == "a" then 
	ctrl.l = -1 
	elseif key:lower() == "d" then 
	ctrl.r = 1 
	end 
	end) 
	mouse.KeyUp:connect(function(key) 
	if key:lower() == "w" then 
	ctrl.f = 0 
	elseif key:lower() == "s" then 
	ctrl.b = 0 
	elseif key:lower() == "a" then 
	ctrl.l = 0 
	elseif key:lower() == "d" then 
	ctrl.r = 0 
	end 
	end)
	
	plr.Character.Humanoid.StateChanged:Connect(function(o,n)
		if n == Enum.HumanoidStateType.Running then
			ctrl.f = 1
		else
			ctrl.f = 0
		end
	
	end)
	script.Parent.TextButton.MouseButton1Click:Connect(function()
		if flying then
			flying = false
			speed = _G.FlySpeeed3
		else
			flying = true
			Fly()
		end
	end)
	
end
coroutine.wrap(NQWSTGE_fake_script)()
local function RAQA_fake_script() -- Frame.Buttons 
	local script = Instance.new('LocalScript', Frame)

	local Trigger = script.Parent.MiniTrext
	local IsMini = false
	function CreateTween(Instance,Style,Direction,Time,table,RepeatCount,CanRepeat,Delay)
		local ts = game:GetService("TweenService")
		local TweenInfo = TweenInfo.new(Time,Style,Direction,RepeatCount,CanRepeat,Delay)
		local Tween = ts:Create(Instance,TweenInfo,table)
		repeat wait() until Tween ~= nil
		return Tween
		
	end
	Trigger.MouseButton1Click:Connect(function()
		if IsMini then
			CreateTween(script.Parent,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0.5,{Size = UDim2.new(0.265, 0,0.1, 0)},0,false,0.1):Play()
			IsMini = false
			Trigger.Text = "-"
		else
			CreateTween(script.Parent,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0.5,{Size = UDim2.new(0.265, 0,0.042, 0)},0,false,0.1):Play()
			IsMini = true
			Trigger.Text = "+"
		end
	end)
	script.Parent.Delete.MouseButton1Click:Connect(function()
		script.Parent.Parent:Destroy()
	end)
end
coroutine.wrap(RAQA_fake_script)()
local function TKVUMP_fake_script() -- Frame.Drag Gui 
	local script = Instance.new('LocalScript', Frame)

	local UserInputService = game:GetService("UserInputService")
	
	local gui = script.Parent
	
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	local function update(input)
		local delta = input.Position - dragStart
		gui.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	UserInputService.InputChanged:Connect(function(input)
		if input == dragInput and dragging then
			update(input)
		end
	end)
end
coroutine.wrap(TKVUMP_fake_script)()
end)
Section:NewLabel("========================================")

--Credits

local Tab = Window:NewTab("Credits")
    local Section = Tab:NewSection("------------------------------------------------------------------")
    Section:NewLabel("Creator : Solo script")
    Section:NewLabel("Solo script founder : lolocahhh45")
    Section:NewLabel("Discord-https://discord.com/invite/fzSAVMKGzv")
    Section:NewKeybind("Gui toggle", "Toggle gui with F or changue to other key", Enum.KeyCode.F, function()
        Library:ToggleUI()
    end)
    Section:NewButton("COPY DISCORD SERVER", "", function()
        setclipboard("https://discord.com/invite/fzSAVMKGzv")
    end)
end

